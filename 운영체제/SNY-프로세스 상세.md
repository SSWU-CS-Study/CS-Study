# 프로세스 상세

<br>

<br>

## 프로세스(Process)

- 운영 체제로부터 자원을 할당 받은 작업의 단위를 의미
- 프로그램이 실행된 상태를 의미

<br>

### 프로세스의 문맥(Context)

프로세스가 실행돼서 종료될 때까지 항상 CPU에서 명령을 처리하면 좋겠지만, 여러 프로세스가 함께 수행되는 시분할 환경에서는 각 프로세스들이 CPU를 자주 빼앗기고 획득하게 된다.

따라서 CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면, **CPU를 빼앗기기 전에 어느 부분까지 명령을 수행했는지 정확한 프로세스의 상태를 재현할 필요가 있다.** 이때 정확한 재현을 위해 필요한 정보가 바로 프로세스의 문맥(context)이다.

즉, **프로세스의 문맥은 프로세스의 메모리(Stack, Data, Code)를 비롯해 CPU 레지스터에 저장된 데이터, 시스템 콜을 통해 커널에서 수행한 작업들의 현황, 프로세스에 대해 커널이 관리하고 있는 각종 정보 등을 포함**하게 된다.

프로세스의 문맥은 3가지로 나눌 수 있다.

1. **하드웨어 문맥**

   프로세스에 대한 CPU 수행 상태를 나타내는 것을 하드웨어 문맥이라고 부르며 각종 레지스터를 일컫는다.

   어디까지 실행했는가? → Program Counter

   어떤 논리로 처리해야 하는가? → ALU(arithmetic login unit)

2. **프로세스의 주소 공간**

   프로세스가 가지고 있는 코드와 데이터, 그리고 로직을 수행하는 스택

3. **프로세스 관련 커널 자료구조**

   - **PCB(Process Control Block)** : 프로세스의 상태에 대한 데이터(메타데이터)가 담겨있는 자료구조
   - **커널 스택(Kernel stack)** : 프로세스가 커널(OS 코드)를 호출 했을 때, 해당 메서드가 실행되는 프로세스만의 스택 다른 프로세스도 OS를 호출할 것이기 때문에, 서로 섞이고 꼬이는 것을 방지하기 위해 각 프로세스 마다 고유한 커널 스택이 있다.

<br>

### 프로세스의 상태(State)

프로세스의 상태는 계속해서 변경된다.

![image-20230514173355306](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230514173355306.png)

- 실행 

  Running

  - CPU에 의해 실행중인 상태

- 준비 

  Ready

  - CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)

- 봉쇄 

  Blocked (stopped)

  - 메모리에 프로그램이 올라가 있지만, CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태
  - 프로세스가 요청한 이벤트(I/O 등)가 완료되지 않아 이를 기다리는 상태, 이벤트를 기다리고 있는 상태
  - Swap 공간에 있는 메모리에 접근할 때도 Blocked가 된다! (디스크에서 파일을 읽어와야 하는 경우이므로)

- Suspended (stopped)

  - 외부적인 이유로 프로세스의 수행이 정지된 상태
  - 프로세스는 통재로 디스크에 Swap out된다. | swap out : 적재된 페이지를 디스크로 저장하는 과정
  - 사용자가 프로그램을 일시 정지(break key)시키거나, 시스템에 메모리에 너무 많은 프로세스가 올라와 있어 프로세스를 잠시 중단시킨 경우

- 시작 

  New

  - 프로세스가 생성 중인 상태

- 완료 

  Terminated

  - 수행(execution)이 끝난 상태

suspend와 커널 모드 내용이 추가된 상태변화도

- 프로세스가 생성되면 New에서 Ready가 된다.
- Ready에서 CPU를 할당받으면 Running이 된다
- CPU를 얻은 상태에서 내려 놓는 경우
  - `Running` → `Terminated` : 본인의 역할을 다하면 종료됨
  - `Running` → `Waiting` : I/O 같은 작업을 하면, CPU가 `Blocking` 되어 명령을 수행할 수 없으므로 `Waiting` 이 된다.
  - `Running` → `Ready` : `Timer` 에 지정된 CPU 사용시간이 끝나면 `Ready` 가 된다.

<br>

<br>

## Process Control Block(PCB)

PCB란, 운영체제가 프로세스들을 관리하기 위해 각 프로세스들의 정보를 담는 커널 내의 자료구조이다. 운영체제가 프로세스를 제어하기 위해 정보(메타데이터)를 저장해 놓는 곳으로, **한 PCB 안에는 한 프로세스의 정보**가 담긴다.

- **프로그램 카운터(PC, Program Counter)**

  프로세스가 다음에 실행할 명령어의 주소를 나타낸다.

- **CPU 레지스터들**

  컴퓨터의 구조에 따라 다양한 수와 유형을 가진다. 프로그램 카운터 + 상태정보는 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록하기 위해서 인터럽트 발생 시 업데이트

- **CPU 스케줄링 정보**

  프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함

- **메모리 관리 정보**

  운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레지스터와 한계(limit) 레지스터의 값, 페이지 테이블, 세그먼트 테이블 등과 같은 정보를 포함

- **accounting 정보**

  CPU 사용 시간과 경과된 실시간, 시간제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함

- **입출력 상태 정보**

  프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

<br>

<br>

## Context Switching 문맥 교환

- **CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정**
- **실행 중이던 프로세스의 상태를 PCB에 보관하고, 새로 들어오는 프로세스 PCB 정보를 바탕으로 레지스터에 값을 적재하는 과정**

Context Switching이란 사용자 프로세스로부터 다른 사용자 프로세스로 **CPU의 제어권을 넘겨주는 과정으**로, CPU의 현재 상태, 프로세스의 현재 상태들을 모두 정리하여 PCB에 저장한 후 캐시 메모리를 비우는 작업이 진행된다. CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.

사용자 프로세스가 CPU를 할당 받고 실행되던 중에 타이머 인터럽트가 발생하면, CPU의 제어권이 운영체제에게 넘어가게 된다. 운영체제는 ISR을 통해 타이머 인터럽트 처리를 시작하며, 직전까지 수행 중이던 프로세스의 모든 상태를 PCB에 저장하고 `Ready` 상태의 프로세스에게 CPU의 제어권을 넘긴다.

이 과정에서 원래 수행 중이던 프로세스는 `Running` → `Ready` 등의 상태로 바뀌고 새롭게 CPU를 할당 받은 프로세스는 `Ready` → `Running` 상태가 된다.

**Context Switching 중 원래 CPU를 할당받았던 프로세스는 자신의 모든 상태를 자신의 PCB에 저장하고, 새롭게 CPU를 할당 받은 프로세스는 예전에 저장했던 자신의 상태를 자신의 PCB로부터 불러오는 과정을 거친다.**

<br><br>

## 프로세스 스케줄링(Process Scheduling)

프로세스 스케줄러란, **어떤 프로세스에게 CPU를 할당할지를 결정하는 운영 체제 함수**를 의미한다.

프로그래밍에서 중요한 것은 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다. 프로세스 스케줄러는 실행가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다. 만약 코어가 여러개라면 한 번에 여러개의 프로세스를 실행할 수 있다. 코어 수보다 더 많은 프로세스가 있는 경우 초과 프로세스는 코어가 다시 사용 가능해지고 스케줄될 때까지 기다려야한다.

**스케줄러의 종류**

- Long-Term Scheduler

   (장기 스케줄러 or Job scheduler)

  - `New` 상태의 프로세스들 중 어떤 것들을 `Ready Queue` 로 보낼지 결정한다
  - 프로세스에 메모리를 할당하는 문제에 관여한다.
  - `degree of Multiprogramming` 을 제어. 메모리에 프로세스가 10개 올라가있다면 `degree of Multiprogramming` 는 10이다.
  - `degree of Multiprogramming` 이 너무 낮아도 CPU 효율이 제대로 안나오고(CPU가 높아서), 너무 높아도 효율이 안나온다(컨텍스트 스위칭 등)
  - 현대의 시분할 시스템에는 보통 장기 스케줄러가 없다. `New` 상태의 프로세스는 전부 `Ready Queue` 에 삽입한다.

- Medium-Term Scheduler

   (중기 스케줄러 or Swapper)

  - 메모리 여유 공간 마련을 위해 프로세스를 통째로 디스크의 스왑 영역으로 밀어낸다(Swap Out)
  - 장기 스케쥴러가 없는 시스템(현대의 컴퓨터 시스템)에서 `degree of Multiprogramming` 을 제어
  - 주로 `blocked` 상태에 있는 프로세스들을 `Swap out` 하고, 그래도 메모리 공간이 부족하면 `Ready Queue` 후반부에 있는 프로세스들을 `Swap out` 한다.

- Short-Term Shcedular

   (단기 스케줄러 or CPU scheduler)

  - 어떤 프로세스를 다음 번에 `Running` 할지 결정
  - 프로세스에 CPU를 주는 문제
  - 충분히 빨라야 한다. (ms 단위)

<br>

<br>

## 프로세스의 주소 공간

프로세스는 메모리를 할당 받으면, 자신 만의 방법으로 메모리를 관리하기 위해 이러한 공간들을 어떤 구조로 관리하게 되는데, 이를 프로세스 주소 공간이라고 부른다. 메모리는 한정되어 있기 때문에, 프로세스는 다양한 방법으로 메모리를 절약하기 위해 시도한다.

프로세스 주고 공간에는 다음 4가지 영역으로 이루어져있다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다.

![image-20230514173332689](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230514173332689.png)

### 스택 영역(stack)

지역변수, 매개변수, 반환 값 등 **일시적인 데이터**를 저장한다. 변수는 변할 수 있으므로, **읽고 쓰기가 가능하다(rw)**

- **함수의 호출과 관계되는 지역변수와 매개변수가 저장**
- stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- 메모리의 **높은 주소에서 낮은 주소의 방향**으로 할당
- **동적**인 특징

### 힙 영역(heap)

동적 할당할 때 사용되며 런타임 시 크기가 결정된다.

- **런타임에 크기가 결정**되는 영역
- 사용자에 의해 공간이 동적으로 할당 및 해제
- 주로 참조형 데이터(ex.클래스) 등의 데이터가 할당
- 메모리의 **낮은 주소에서 높은 주소의 방향**으로 할당
- **동적**인 특징

### 데이터 영역(BSS segment, Data segment)

전역 변수와 같은 데이터를 관리하는 부분으로, 함수의 바깥에 있는 데이터(**전역 변수)를 저장**해 놓는다고 보면된다. 변수는 변할 수 있으므로 **읽고 쓰기가 가능하다(rw)**

- 전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역
- **프로그램이 종료되면 소멸**된다
- **초기화되지 않은 변수가 존재하면, BSS 영역에** 저장된다.
- **정적**인 특징

### 코드 영역(Code Segment)

프로그램 **소스 코드가 저장된 부분**으로, 프로그램의 코드가 바뀌어서는 안되기 때문에 **읽기만 가능하다(r)**

- 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간
- 프로그램이 수정되면 안되므로 **ReadOnly 상태로 저장**
- **정적**인 특징

<br>

### 정적 할당과 동적 할당

#### 정적 할당

컴파일 단계에서 메모리를 할당하는 것으로, BSS segment와 Data segment, Code segment로 나뉘어서 저장된다.

- BSS segment는 전역 변수, static, const로 선언되어 있는 변수 중 0으로 초기화 또는 초기화가 어떤 값으로도 되어 있지 않은 변수들이 메모리 영역에 할당 된다.
- Data segment는 전역변수, static, const로 선언되어 있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당 된다.
- Code segment에는 프로그램 코드가 들어간다.

#### 동적 할당

동적 할당은 런타임 단계에서 메모리를 할당 받는 것으로, Stack과 Heap으로 나눠진다.

- stack은 지역 변수, 매개 변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다. 함수가 호출될 때마다 특정 정보가 stack에 계속 저장된다.
- heap은 동적으로 할당되는 변수들을 담는다. `malloc()` `free()` 함수를 통해 관리할 수 있으며, 동적으로 관리되는 자료구조의 경우 Heap 영역을 사용한다. 예로 `vector` 는 내부적으로 heap 영역을 사용한다.

<br>

그렇다면 왜 이렇게 구역을 나누게 된 걸까?

**최대한 데이터를 공유하여 메모리 사용량을 줄여야하기 때문**이다.

1. 왜 Code 부분을 따로 두었나?

프로그램의 코드는 프로그램이 만들어지고 나서는 바뀔 일이 전혀 없다. 따라서 읽기만 가능한 Read Only 부분이고, 그렇기 때문에 같은 프로그램을 실행시켜 여러개의 프로세스가 실행되더라도, 같은 프로그램이라면 Code 부분은 다 똑같은 내용을 가지게 된다.

1. 왜 Stack 부분과 Data 부분을 나누었나

스택 구조의 특성과 전역 변수의 활용성을 위해서이다. 함수는 Stack 구조로 진행되기 때문에, 나누게 되었다. 전역 변수는 어떤 함수에서든 접근할 수 있기 때문에 Data로 따로 관리를 해둔다. 어떤 함수에서는 공통으로 사용하는 전역 변수를 따로 지정해둠으로써 메모리를 아낄 수 있는 것이다. 따라서 함수 외부(Outside function)과 함수(Inside function, 지역 변수 포함)에 따라서 Stack 구조 활용을 위해 나누었다고 생각하면 된다.