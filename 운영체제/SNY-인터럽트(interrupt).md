# 인터럽트(interrupt)

<br>

<br>

주변 장치와 입출력 장치는 CPU나 메모리와 달리 인터럽트(interrupt)라는 메커니즘을 통해 관리된다.

그렇다면 **인터럽는** **왜 하는 것**일까?

그 이유는 <u>입출력 연산이 CPU 명령 수행 속도보다 현저히 느리기 때문</u>이다. 

<br>

운영 체제를 악덕 사장님, CPU를 비싼 월급 주고 데려온 고급 인력이라고 생각해보자. 악덕 사장 입장에서는 비싼 돈을 들여온 만큼 고급 인력이 쉬지 않고 일해서 돈값을 했으면 좋겠다고 생각할 것이다. 

<img src="https://hiphapis.files.wordpress.com/2014/03/screen-shot-2014-03-18-at-4-49-54-pm.png?w=250" width=200/>

그런데 만약 아주 오래걸리는 입출력 연산을 CPU가 매번 기다린다면(월급 루팡 한다면)??! 비싼 돈 주고 모셔온 CPU를 백분 활용하지 못해 운영체제 사장님은 환장할 지경이 될 것이다. CPU가 입출력 처리를 기다리며 쉬는 꼴을 못보는 사장님은 연산 결과가 나올 때까지 다른 일을 시킨다. (직원 뽕을 뽑아야 하니까!) 그리고 입출력 직원에게 자신의 업무가 완료되면 그때 CPU 선배님에게 작업 완료를 알리라고 일러둔다. 그래서 CPU가 다시 해당 작업도 이어서 할 수 있도록 한다. 여기서 입출력 직원이 CPU 선배님에게 작업 완료를 알려주는 것이 **<u>인터럽트</u>**이다.

<br>

<br>

## 인터럽트(interrupt)란?

**CPU가 프로그램을 실행하는 도중에** 입출력 하드웨어 등의 장치나 예외 상황이 발생할 경우 실행 중인 작업을 중단하고, **발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것**이다. 이때 인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.

<br>

### 하드웨어/외부 인터럽트

하드웨어가 발생시키는 인터럽트로, CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나 CPU 서비스를 요청해야할 경우 발생시킨다. 

- 전원 이상 인터럽트 : 정전이나 전원이 이상이 있는 경우
- 기계 고장 인터럽트 : CPU 등의 기능적인 동작 오류가 발생한 경우
- 입출력 인터럽트(I/O) : 입출력의 종료 등의 이유로 CPU의 수행을 요청하는 인터럽트
- 외부 신호 인터럽트 : I/O 장치가 아닌 오퍼레이터나 타이머에 의해 이도적으로 프로그램이 중단된 경우

### 소프트웨어/내부 인터럽트

소프트웨어가 발생시키는 인터럽트로, 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다. 

프로그램 처리 중 명령의 요청에 의해 발생하는 것으로, 사용자가 프로그램을 실행시킬 때 발생한다.  

> 소프트웨어 이용 중에 다른 프로세스를 실행시키면, 시분할 처리를 위해 자원 할당 동작이 수행된다. 

- 프로그램 검사 인터럽트 : CPU 내부에서 실행하면서 인터럽트에 걸리는 경우
  - 0으로 나누는 경우
  - 오버플로우 또는 언더플로우가 발생한 경우
  - 프로그램 상의 오류
  - 프로그램에서 함수 등 명령어를 잘못 사용한 경우
- SVC 인터럽트(==Trap)
  - 사용자가 프로그램을 실행시키거나 supervisor(OS)을 호출하는 동작을 수행하는 경우
  - 프로그래머에 의해 코드로 짜인 감시 프로그램을 호출하는 방식

<br>

인터럽트를 발생시키기 위해 하드웨어/소프트웨어는 CPU 내에 있는 `인터럽트 라인`을 세팅하여 인터럽트를 발생시킨다. CPU는 매번 명령을 수행하기 전에 인터럽트 라인이 세팅되어 있는 지를 검사한다.

<br>

<br>

## 인터럽트 발생 과정

process A 실행 중, 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정해보자.

![img](https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2)

1. Process A는 system call을 통해 인터럽트를 발생시킨다.
2. CPU는 현재 실행 중인 명령어를 완료한다. 
3. 현재까지 수행중이었던 상태를 해당 process의 PCB(Process Control Block)에 저장한다. (수행 중이던 메모리 주소, 레지스터 값, 하드웨어 상태 등...)
4. PC(Program Counter, IP)에 다음에 실행할 명령의 주소를 저장한다.
5. 인터럽트 벡터를 읽고 ISR 주소값을 얻어, ISR(Interrupt Service Routine)로 점프하여 루틴을 실행한다. 
6. 해당 코드를 실행한다.
7. 해당 일을 다 처리하면, 대피시킨 레지스터를 복원(프로세스의 상태를 복원)한다.
8. ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제 된다. 
9. IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원한다

<img src="https://raw.githubusercontent.com/na3150/typora-img/main/uPic/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-04-16%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.14.58.png" width=500/>

> Interrupt Vector
>
> - 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야할 코드가 위치한 부분을 가리키는 자료구조
> - 인터럽트 요청이 발생했을 때, CPU는 인터럽트 소스가 무엇이며, 해당 인터럽트 ISR이 어디에 적재되어 있는 지를 확인해야한다. 이때 인터럽트 벡터를 활용한다.
> - 인터럽트 벡터를 따라가면 실제 처리해야할 코드는 인터럽트 처리 루틴 또는 인터럽트 핸들러라고 불리는 다른 곳에 정의된다.
>
> ISR
>
> - 인터럽트 서비스 루틴(Internet Service Routing), 인터럽트 핸들러(Interrupt Handler)라고도 한다
> - 실제 인터럽트를 처리하기 위한 루틴으로, 운영체제의 코드 영역에는 인터럽트 별로 처리해야할 내용이 이미 프로그램 되어 있다.
> - 인터럽트가 접수되면 각각의 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴
>
> IRET 명령어
>
> - Interrupt Return, 이전 task로 돌아가는 어셈블리 명렁어
> - ISR의 마지막. 명령어
>
> PCB(Process Control Block)
>
> - 커널의 데이터 영역에 존재하며, 각각의 프로세스마다 고유의 PCB가 있음
> - 인터럽트 발생 시 프로세스의 어느 부분이 수행중이었는 지를 저장

<br>

<br>

## 우선 순위

**만약 인터럽트 처리 중 또다른 인터럽트가 발생한다면 어떻게 될까?**

하나의 인터럽트를 처리 중인 경우에 원칙적으로는 또 다른 인터럽트의 처리를 허용하지 않는다. 인터럽트가 발생해서 운영체제 커널에 정의된 데이터를 변경하고 있는 상황에 또다른 인터럽트 발생해서 같은 데이털르 수정하게 되면, 의도하지 않은 결과값으로 바뀔 수 있기 때문이다.

<br>

그러나 예외적인 경우가 존재한다. 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트가 발생하면 인터럽트를 허용한다. 이때는 현재 처리 중이던 인터럽트 코드의 수행 지점을 커널 스택에 저장한 뒤, 우선적으로 처리할 인터럽트를 처리한 뒤, 이전에 실행 중이던 인터럽트 코드 부분으로 되돌아와 남은 부분을 처리하게 된다. 

### 인터럽트 우선 순위

- 전원 이상 인터럽트
- 기계 고장 인터럽트
- 외부 신호 인터럽트
- 프로그램 인터럽트
- SVC

<br>

만약 인터럽트 기능이 없다면, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야한다. 이를 폴링(Polling)이라 하고, 폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어, 많은 기능을 제대로 수행하지 못한다는 단점이 있다.

<br>

### 우선 순위 판별 방법

즉, 컨트롤러가 입력을 받아들이는 방법(우선 순위 판별방법)에는 두가지가 있다. 

- 폴링 방식
  - 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
  - 인터럽트 요청 플래그를 차례로 비교하여 우선 순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. (하드웨어에 비해 속도 느림)
  - 인터럽트를 조사하는 비용이 들어 반응 시간이 느리지만, 하드웨어를 추가할 필요가 없어 회로가 간단하다.
- 인터럽트 방식
  - MCU 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
  - 어디에 인터럽트가 발생하는지 확인하는 회로를 직렬로 연결하는 하드웨어적인 방법
  - Daisy Chain, 병렬 우선순위 부여

<br>

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 실시간 대응이 필요할 때는 필수적인 기능이라고 할 수 있다. 즉 인터럽트는, 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법이다. 

<br>

<br>

<br>

<br>

<br>

Reference

- [링크](https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)

