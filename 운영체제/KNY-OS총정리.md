# os 정리

# 1. **Thread vs Process**

## Thread

> 프로세스 내 실행되는 여러 흐름의 단위프로세스의 특정한 수행 경로
프로세스가 할당받은 자원을 이용하는 실행의 단위라고 할 수 있다.
> 

- thread는 프로세스 내 각 stack만 따로 할당받고 code, data, heap 영역은 공유한다.
- thread는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내 주소 공간이나 자원들을 같은 프로세스 내 thread끼리 공유하며 실행된다.
- **같은 프로세스 안에 있는 여러 thread들은 같은 힙 공간을 공유**하는 반면 **프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.**
- 각 thread는 별도의 레지스터와 스택을 가지고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 한 thread가 프로세스 자원을 변경하면, 다른 이웃 thread(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

## Process

> 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
os로부터 시스템 자원을 할당받는 작업의 단위
동적인 개념으로는 실행된 프로그램을 의미한다.
> 

- 프로세스는 각 독립된 메모리 영역(code, data, stack, heap)을 할당받는다.
- 기본적으로 프로세스당 최소 1개의 thread(main thread)를 가진다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신[(IPC](https://www.notion.so/os-a9349629411e41159f5cfcc00e1fc012))을 사용해야 한다. 
(Ex. 파이프, 파일, 소켓 등을 이용한 통신 방법)

## Multi Process vs Multi Thread

### Multi Process

> 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)을 처리
> 

**`장점`**

- 여러개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽고 다른 것에 영향을 미치지 않는다.

`**단점**`

- [Context Switching](https://www.notion.so/os-a9349629411e41159f5cfcc00e1fc012)에서의 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생한다.
- 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이 공유하는 메모리가 없어, Context Switching이 발생하면 캐시에 있는 모든 데이터를 모두 리셋하고 다시 캐시 정보를 불러와야 한다.
- 프로세스 사이 어렵고 복잡한 통신 기법(IPC)프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.

### Multi Thread

> 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리
웹 서버가 대표적인 멀티 스레드 응용 프로그램
> 

**`장점`**

- 시스템 자원 소모 감소 (자원의 효율성 증대)프로세스를 생성해 자원을 할당하는 시스템 콜이 감소해 자원을 효율적으로 관리
- 시스템 처리량 증가 (처리 비용 감소)스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모 감소스레드 사이 작업량이 작아 Context Switching이 빠름
- 간단한 통신 방법으로 인한 프로그램 응답 시간 단축스레드는 프로세스 내 stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적음

`**단점**`

- 주의깊은 설계가 필요
- 디버깅 까다로움
- 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
- 다른 프로세스에서 스레드를 제어할 수 없음 (즉, 프로세스 밖에서 스레드를 각각 제어할 수 없음)
- 멀티 스레드의 경우 자원 공유의 문제 발생 (동기화 문제)
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

<aside>
💡 **멀티 프로세스 대신 멀티 스레드를 사용하는 이유**

> 프로그램 여러 개(멀티 프로세스) vs 하나의 프로그램 안에서 여러 작업(멀티 스레드)
> 

우선, 프로세스를 생성해 자원을 할당하는 시스템 콜이 줄어들기 때문에 **자원의 효율성을 높일 수 있다.**멀티 프로세스일 때는 프로세스 간 Context switching시 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리에 대한 데이터까지 초기화되므로 오버헤드가 크다.하지만 스레드는 프로세스 내 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어든다.

또한 **처리 비용 감소되고 응답 시간이 단축된다.**프로세스 간 통신(IPC)보다 스레드 간 통신 비용이 적어 작업들 간의 통신 부담이 줄어든다. (스레드는 stack 영역을 제외한 모든 메모리를 공유하기 때문)프로세스 간 전환 속도보다 스레드 간 전환 속도가 빠르다. (context switching시 스레드는 stack 영역만 처리하기 때문)

하지만 스레드 간 자원 공유는 전역 변수 (데이터 세그먼트)를 이용하므로 함께 상용할 때 충돌이 발생할 수 있다는 점을 주의해야 한다.

</aside>

---

* IPC : Inter-Process Communication프로세스들 사이 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로

* Context Switching: CPU에서 여러 프로세스를 돌아가며 작업을 처리하는데 이 과정을 Context Switching이라고 함

# 2.  PCB

> Process Control Block : **운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳**
프로세스의 상태 정보를 저장하는 자료구조
> 

운영체제에서 프로세스는 PCB로 표현된다.프로세스가 생성될 때마다 고유 PCB가 생성되고 프로세스가 완료되면 PCB도 함께 제거된다.

이는 프로세스 상태 관리와 Context Switching을 위해 필요하다.

OS에 따라 PCB에 포함되는 항목이 다를 수 있지만 일반적으로 `포인터`, `프로세스 상태`, `프로세스 번호`, `프로그램 카운터`, `레지스터`, `메모리 제한`,`열린 파일 목록`...이 있다.

OS는 빠르게 PCB에 접근하기 위해 **프로세스 테이블**을 사용해 각 프로세스의 PCB를 관리한다.

# 3.  Deadlock (교착상태)

> **프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태**
시스템적으로 한정된 자원을 여러 곳에서 사용할 때 발생
> 

### Deadlock 발생 조건

교착 상태는 한 시스템 내에서 다음 네 가지 조건이 동시 성립될 때 발생한다.

1. **상호 배제(Mutual exclusion)**자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
2. **점유 대기(Hold and wait)**최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
3. **비선점(No preemption)**다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
4. **순환 대기(Circular wait)**프로세스의 집합 {P0, P1, ... Pn}에서 P0은 P1이 점유한 자원을 대기, P1은 P2가 점유한 자원을 대기 ... Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0이 점유한 자원을 요구해야 한다.

# 4.  DB Transaction

> `Transaction`: 쪼개질 수 없는 업무처리의 단위
`commit`: 모든 부분 작업이 정상적으로 완료되면 이 변경사항을 한번에 DB에 반영
`rollback`: 부분 작업이 실패하면 트랜잭션 실행 전으로 되돌림
> 
- DB 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
- DB 시스템에서 복구 및 병행 수행 시 처리되는 작업의 논리적 단위
- 한꺼번에 수행되어야 하는 일련의 연산

### 특징 (ACID)

- **원자성(Atomicity)**: 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.
- **일관성(Consistency)**: 트랜잭션의 작업 처리 결과는 항상 일관성을 가져야 한다.
- **독립성(Isolation)**: 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. (하나의 특정 트랜잭션이 완료될 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.)
- **영속성(Durability)**: 트랜잭션이 성공적으로 완료 되었다면 결과는 영구적으로 반영되어야 한다.

# 5.  동기화

## 임계 구역(Critical Section)

> 프로세스 간 공유 자원을 접근하는 데 있어 문제가 발생하지 않도록 한 번에 하나의 프로세스만 이용해 다른 프로세스들의 접근을 제한하는 영역
> 

### 임계 구역 문제를 해결하기 위한 방법

1. **상호 배제(Mutual Exclution)** - *스핀락*, *뮤텍스*: 하나의 프로세스가 임계 구역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
2. **진행(Progress)**: 들어가려는 프로세스가 여러 개라면 어느 것이 들어갈지 결정해주어야 한다.
3. **한정된 대기(Bounded Waiting)**: 다른 프로세스의 기아(Starvation)를 막기 위해 한 번 임계 구역에 들어간 프로세스는 다음번 임계 구역 접근에 제한이 생겨야 한다.

## 스핀락 (Spinlock)

> **특정한 자원을 획득(Lock) 또는 해제(Unlock)를 통해 공유 자원에 대한 접근 권한을 관리하는 방법**
> 

권한을 획득하기 전까지 CPU는 무의미한 코드를 수행하는 Busy Waiting 상태로 대기하고 있다가 접근 권한을 얻게되면 내부 코드를 수행하고 종료 후 권한을 해제한다.

상태가 획득, 해제 뿐이기 때문에 공유 영역에서는 하나의 컴포넌트만 접근이 가능하다.(획득, 해제의 주체는 동일해야 한다.)

**하나의 작업이 빠르게 수행**될 수 있다는 장점이 있지만, 선**점 기간 동안에는 다른 프로세스의 작업이 지연될 수 있는 오버 헤드가 존재**한다.그래서 짧게 수행할 수 있는 작업에 주로 사용된다.

## 뮤텍스 (Mutex)

> **MUT**ual **EX**clusion으로 상호 배제라고도 한다.
> 

획득(Lock), 해제(Unlock) 상태가 있으며 스핀락과 같이 접근 권한을 획득할 때까지 **BusyWating 상태에 머무르지 않고 Sleep 상태**가 되며 Wakeup이 되면 권한 획득을 시도한다.

뮤텍스의 경우엔 Locking 메커니즘으로 오직 하나의 스레드만이 동일 시점에 뮤텍스를 얻어 임계 구역(Critical Section)에 접근할 수 있다.(마찬가지로 획득, 해제의 주체는 동일해야 한다.)

## 세마포어 ( Semaphore)

> 스핀락과 뮤텍스와는 다르게 **하나 이상의 스레드가 공유 자원에 접근할 수 있도록** 함(예전에 많이 사용되던 방식)
> 

표현형은 정수로 표현하며 획득, 해제가 아닌, 값을 올리고 내리는 방식을 사용한다.

컴포넌트가 특정 자원에 접근할 때 `semWait`이 먼저 호출되어 임계 구역에 들어갈 수 있는지 확인한다.조건에 만족한다면 `semWait`을 빠져나와 임계 구역에 들어가게 되고 이후 `semSignal`이 호출되어 임계 구역을 빠져나오게 된다.

> semWait연산: 세마포어의 값을 감소시킴만약 값이 음수가 되면 semWait을 호출한 스레드는 블록되지만 음수가 아니라면 스레드는 작업을 수행
> 
> - `semSignal`연산: 세마포어의 값을 **증가**시킴만약 **값이 양수가 아니라면** `semWait` **연산에 의해 블록된 스레드들을** `wake` 시킴

<aside>
💡 **세마포어 vs 뮤텍스**

세마포어의 경우 여러 개의 스레드가 접근할 수 있는 반면 뮤텍스는 오직 한 개의 스레드만 접근 가능세마포어는 현재 수행 중인 스레드가 아닌 다른 스레드가 세마포어 해제를 할 수 있지만 뮤텍스의 경우 획득하고 해제하는 주체가 동일해야 함 (lock을 획득한 프로세스가 unlock까지)

</aside>

## 모니터 Monitor

> 상호배제 락에 의해 보호되는 일련의 루틴락을 획득하기 전까지는 스레드에서 모니터에 속하는 어떤 루틴도 실행시킬 수 없다.
> 

모니터 안 항상 하나의 프로세스만이 활성화 되도록 보장하여 프로그래머들은 동기화 제약 조건을 명시적으로 코딩하지 않아도 된다.(자바 프로그램에서는 모니터에 대한 활용이 활발)

모니터는 세마포어 이후 프로세스 동기화 도구이다. 그리고 세마포어보다 고수준 개념을 담고있다.

> 공유자원 + 공유자원 접근함수로 구성2개의 queues: 배터동기(Mutual exclusiton queue) + 조건동기(Conditional synchronization)공유자원 접근함수에는 최대 한 개의 스레드만 진입 가능➡️ 나머지 진입하지 못한 스레드들은 큐에서 대기 (Mutual exclusion queue)진입 스레드가 조건 동기로 블록되면 새 스레드 진입 가능➡️ wait call들어왔던 스레드는 Conditional synchronization에 갇히게 되고 새 스레드는 진입 가능해짐새 스레드는 조건동기로 블록된 스레드를 깨울 수 있음➡️ notify(): 블록됨 스레드를 깨움깨워진 스레드는 현재 스레드가 나가면 재진입 가능➡️ 하나의 스레드만 있을 수 있으므로 그 비워진 자리에 깨워진 스레드가 들어올 수 있게 됨
> 

자바에서는 모든 객체가 모니터가 될 수 있다.

- **배타동기**: `synchronization` 키워드를 사용해 지정. 한 스레드에만 접근 가능.
- **조건동기**: `wait()`, `notify()`, `notifyAll()` 메소드 사용

<aside>
💡 **세마포어 vs 모니터**

세마포어에 비하여 모니터 쪽이 공유자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해 간단하다.세마포어는 직접 키 해제와 공유자원 접근 처리를 해주어야 한다.

</aside>
