# 데드락(Deadlock)

<br>

<br>

## Deadlock

운영체제에서 데드락(교착상태)란, 시스템 자원에 대한 요구가 뒤엉킨 상태이다. 두 개 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다. **시스템적으로 한정된 자원을 여러 곳에서 사용하려고할 때 발생**한다.

![image-20230514172815390](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230514172815390.png)

**주로 발생하는 경우**

멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황에 발생한다. 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있다. 이때 프로세스는 대기 상태로 들어가게 되고, 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 ‘교착 상태’가 발생한다.

<br>

<br>

## 발생 조건

교착상태는 다음 4가지 조건을 모두 만족하는 경우(동시에 성립)에만 발생한다.

1. 상호 배제 조건

   (mutal exclusion condition)

   - **한 번에 프로세스 하나만 해당 자원을 사용**할 수 있음
   - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함

2. 점유 대기

   (hold and wait)

   - **자원을 최소한 하나 보유하고**, 다른 프로세스에 할당된 자원을 점유하기 위해 **대기하는 프로세스가 존재해야 함**

3. 비선점

   (no preemption)

   - 이미 할당된 자원을 사용이 끝날 때까지 **강제로 빼앗을 수 없음**

4. 순환 대기

   (circular wait)

   - 대기 프로세스의 집합이 **순환 형태로 자원을 대기**하고 있어야 함

그러나 교착 상태의 필요 조건 4가지를 모두 만족하더라도 교착 상태가 반드시 일어나는 것은 아니다.

> 참고 : 순환대기는 점유 대기와 비선점을 모두 만족해야하만 성립한다. 따라서 4가지가 서로 독립적이진 않음

<br>

<br>

## Deadlock 해결 방법

- 데드락이 발생하지 않도록 예방하기 prevention
- 데드락 발생 가능성을 인정하면서도 적절하게 회피하기 avoidance
- 데드락 발생을 허용하지만, 데드락을 탐지 detection하여, 회복하기 recovery
- 데드락에 아무런 조치를 취하지 않는 무시하기

<br>

### Deadlock 예방

교착 상태가 발생되지 않도록 사전에 예방하는 방법으로, **4가지 발생 조건 중 하나를 제거**함으로써 해결하는 방법이다. 단, 일반적으로 **자원 사용 효율성이 떨어지고 비용이 많이 드는 방법**이다.

1. 상호 배제 조건 제거

   - 하나의 공유 자원에 대해 프로세스들이 동시에 접근할 수 있도록 한다
   - 그러나 현실적으로 불가능하고 추후 동기화 관련 문제가 발생할 수 있음

2. 점유 대기 조건 제거

   - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 함

   특정 프로세스가 어떤 작업을 수행할 때, 해당 작업에 필요한 리소스들을 먼저 요청하고 할당받은 다음에 작업을 수행하므로써 점유대기 조건을 제거할 수 있다. 그러나 자원의 효율성이 떨어진다는 단점이 존재한다. 또한 프로세스들이 어떤 자원을 필요하는지 확인하는 과정에서 오버헤드가 발생한다.

3. 비선점 조건 제거

   프로세스가 다른 프로세스의 자원을 요청하기 위해서 자신이 할당 받았던 자원을 반납해야한다. 다만 여태까지 작업했던 프로세스의 상태를 잃을 수 있는 등의 부작용이 존재한다.

4. 순환 대기 조건 제거

   각각의 자원들에 대해 공유번호를 할당하고, 특정 프로세스는 자신이 할당 받은 자원의 번호를 기준으로 오름차순이나 혹은 내림차순으로만 요청을 할 수 있도록 하는 방식이다.

### Deadlock 회피

데드락 회피 방법은 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않고 안전한 상태에서만 자원 요청을 허용하는 방법이다. **교착 상태 발생 가능성을 검사해서, 발생 가능성이 있다면 사전에 회피**하는 방식이다.

- 안전 순서(safe sequence) : 교착 상태를 발생시키지 않고 자원을 할당하는 순서
- 안전 상태(safe state) : 안전 순서가 존재하며 모든 프로세스가 정상적으로 종료될 수 있는 상태
- 불안정 상태(unsafe state) : 교착 상태가 발생할 가능성이 있는 상태

<br>

다음과 같은 과정을 거쳐 회피하게 된다.

1. 프로세스가 자원 요청 시, 자원을 할당한 후에도 안정 상태로 남아있는지 사전 검사
2. 안정 상태라면 자원을 할당
3. 불안정 상태라면 다른 프로세스가 자원을 해지할 때까지 대기

<br>

**자원을 요청할 때마다 시스템 상태를 검사하는 만큼 오버헤드가 크다.**

데드락 예방법보다는 조금 덜 제한적인 방법으로 예방법의 단점을 일부 해결 가능하지만 아래와 같은 가정이 필요하다.

- 프로세스 수 고정
- 자원의 종류와 수 고정
- 프로세스가 요구하는 최대 자원의 수를 알아야 함
- 프로세스는 자원 사용 후 반드시 반납

회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다. 이러한 특징을 살린 알고리즘으로 유명한 것이 은행원 알고리즘이다.

#### 은행원 알고리즘

다익스트라가 제안한 기법으로, 은행에서 모든 고객의 오구를 충족할 수 있도록 현금을 대출해주는 것에서 유래했다. 어떤 자원의 할당을 허용하는 지에 관한 여부를 결정하기 전에 예상되는 모든 자원의 최대 할당량을 가지고 시뮬레시션하여 안전 상태에 들 수 있는지 여부를 검사하여 **교착 상태의 가능성을 미리 조사하는 알고리즘**이다.

시스템이 총 12개의 자원을 가지고 있다고 가정해보자

| (t=t0) | Max  | Allocation | Need | Available |
| ------ | ---- | ---------- | ---- | --------- |
| P0     | 10   | 5          | 5    |           |
| P1     | 4    | 2          | 2    |           |
| P2     | 9    | 2          | 7    |           |

P0~P2는 프로세스이고, Max는 각 프로세스마다 최대 자원 요청량, Allocation은 현재 프로세스에 할당 중인 자원의 양, Need는 남은 필요한 자원의 양(Max-Allocation)이다.

현재 t0일 때 프로세스에 할당된 자원의 합은 5+2+2=9개이다. 따라서 현재 Available 자원은 12-9=3이다.

- 남은 가용자원 3개를 P1에게 할당 → 현재 Available = 3-2 = 1개
- P1의 작업이 끝나고 할당되어 있던 자원 4개를 반납 → 현재 Available = 1+4 = 5개
- 남은 가용자원 5개를 P0에게 할당 → 현재 Available = 5-5 = 0개
- P0의 작업이 끝나고 할당되어 있던 자원 10개 반납 → 현재 Available = 0+10 = 10개
- 남은 가용자원 10개 중 7개를 P2에게 할당 → 현재 Available = 10-7 = 3개
- P2의 작업이 끝나고 할당되어 있던 자원 9개 반납 → 현재 Available = 3+9 =12개

이처럼 <P1, P0, P2>일 때 안전 순서를 만족한다.

#### 자원 할당 그래프 알고리즘

자원 할당 그래프에 예약 간선을 추가하여 예약 간선으로 설정한 자원에 대해서만 자원 할당을 요청할 수 있고 사이클이 형성되지 않을 때만 자원을 할당 받는 방법

- 자원 할당 그래프 : 프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리는지 방향성이 있는 그래프로 표시한 것
- 예약 산선 : 향후 요청할 수 있는 자원을 가리키는 점선으로 표시된 간선

<br>

### Deadlock 탐지

**시스템에 데드락이 발생했는지에 대한 여부를 탐색**하고 회복 기법 알고리즘에 활용하는 것을 의미한다. 교착 상태가 탐지되었다면 회복 기법을 통해 교착 상태를 복구한다. 그러나 탐지 기법은 **지속적으로 교착 상태를 확인하는 작업이 필요하기 때문에 오버헤드가 발생**하게 된다.

- Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.

- 이외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다

- `자원 할당 그래프`

  ![image-20230514173020543](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230514173020543.png)

  - 프로세스 Pi로부터 Rj로의 방향 간선은 Pi → Rj로 표현하며, 이것은 프로세스 Pi가 자원Rj를 요청하는 것으로 현재 이 자원을 기다리는 상태
  - 자원 Rj로부터 프로세스 Pi로의 방향 간선은 Rj→Pi로 표현하며, 이것은 자원이 프로세스  Pi에 이미 할당된 것을 의미
  - **자원을 요청할 때마다 탐지 알고리즘을 실행하면 그에 대한 오버헤드가 발생**한다.

<br>

### Deadlock 회복

데드락을 탐지 기법을 통해 발견했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용한다.

#### 프로세스 중지

- 교착 상태에 빠진 모든 프로세스를 중단시키는 방법
  - 계속 연산 중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
- 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법
  - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담 가중

#### 자원 선점

- 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법
- 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

<br>

### Deadlock 무시

교착 상태의 필요조건 4가지를 모두 만족하더라도 교착 상태가 반드시 일어나는 것이 아니라고 했듯이, 교착 상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착 상태에 대한 아무런 조치를 하지 않는 방법도 있다.