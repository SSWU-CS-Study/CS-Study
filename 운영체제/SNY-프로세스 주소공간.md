# 프로세스의 주소 공간

### Remind

- 프로세스는 프로그램이 실행된 것이다.
- 스레드는 한 프로세스 내에서 나뉘어진 하나 이상의 실행 단위이다.
- 한 애플리케이션에 대한 작업을 동시에 하기 위해서는 2가지 처리 방식(멀티 프로세스, 멀티 스레드)이 있다.
- 동시에 실행이 되는 것처럼 보이기 위해서 실행 단위는 시분할로 cpu를 점유하며 context swiching을 한다.
- 멀티 프로세스는 독립적인 메모리를 가지고 있지만 멀티 스레드는 자원을 공유한다. 그것에 따른 각각의 장단점이 있다.
- 멀티 코어는 하드웨어 측면에서 실행 단위를 병렬적으로 처리할 수 있도록 여러 프로세서가 있는 것이다.

<br>

<br>

## 프로세스의 상태

프로세스의 주소 공간에 대해 알아보기 앞서, 프로세스의 상태(State)에 대해 알아보자. 프로세스는 프로그램이 실행된 것으로, 다음 그림과 같이 3가지 상태(Ready, Running, Block)를 갖는다. 

<img src="https://t1.daumcdn.net/cfile/tistory/2719A44558F0B53410" width=500/>

운영체제는 프로세스들의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리해야한다. 이를 위해 운영체제는 프로세스의 상태를 `Running`, `Ready`, `Block` 상태로 분류하고, State Transition(상태 전이)를 통해 체계적으로 관리한다. 

### Running State

Running State는 CPU에 의해서 실행되고 있는 상태를 의미한다. 따라서 프로세스가 CPU에 의해 열심히 자기 일을 하고 있는 중이라고 할 수 있다.

### Ready State

Ready State는 말 글대로 준비하고 있는 상태이다. 이 상태에 있는 프로세스들은 CPU allocation(할당)만 받으면 바로 Running State로 들어가 실행을 할 수 있는 상태이다. 

### Block State

Block State는 이벤트를 기다리고 있는 상태이다. 간단히 C언어를 예를 들어보면, scanf 함수가 실행될 때 사용자가 키보드를 통해 값을 입력하고 엔터를 치기 전까지는 프로그램은 아무런 일도 하지 않고 사용자의 응답을 기다리게 된다. 이처럼 이벤트적인 행동을 기다리는 상태(wait for event)를 Block State라고 한다. 

<br>

여기서 그림을 보면 block 상태에서 이벤트가 발생했을 때 왜 running으로 가지 않고, ready로 가게되는지 의문이 생길 수 있는데, 이러한 의문점 들을 간단히 정리해보자.

<br>

1. **왜** `Block State`**가 필요할까?**

만약 `Block State`가 없다면 사용자의 응답을 `Running State`에서 받게될 것이다. 그렇게 되면 사용자가 금방 응답하는 경우는 문제가 없겠지만, 그렇지 않은 경우 CPU 효율의 낭비로 이어지게 된다. 따라서 효율적인 운영체제 운영을 위해 `Block State`가 고안되게 되었다.

2. **왜** `Block State`**가 끝난 뒤** `Ready State`**로 가는가?**

`Ready State`는 CPU가 자신을 실행시켜 주는 것을 기다리고 있는 상태이다. 이러한 이유는 후에 살펴볼 CPU Scheduling과 연관이 있는데, 지금은 그냥 CPU가 한 가지 프로세스만 실행시키는 것이 아니기 때문에 `Ready State`가 있다 정도로만 생각하면 될 것 같다.

<br>

<br>

## 프로세스 주소 공간

프로세스는 메모리를 할당 받으면, 자신 만의 방법으로 메모리를 관리하기 위해 이러한 공간들을 어떤 구조로 관리하게 되는데, 이를 프로세스 주소 공간이라고 부른다. 메모리는 한정되어 있기 때문에, 프로세스는 다양한 방법으로 메모리를 절약하기 위해 시도한다. 

<br>

### Remind

<img src="https://blog.kakaocdn.net/dn/bNonsf/btrdd4JeFN8/ymrroVQSLO7xrBCWKJDtk0/img.png" width=500/>

프로그램이 프로세스가 되면서 일어나는 2가지

1. 프로세스 동작에 필요한 정보들이 메모리에 올라간다. (Code, Data, Heap, Stack 영역이 메모리 확보)
2. 해당 프로세스에 대한 정보를 담고 있는 PCB 블럭이 만들어진다.

<br>

다음 그림과 같이 프로그램이 실행이 되면, 프로세스 주소 공간(Process Address Space)이 Memory에 할당(생성)된다. (프로세스 동작에 필요한 정보들이 메모리에 올라간다) 그리고 이렇게 할당된 프로세스의 실행은 CPU가 담당한다. 

<img src="https://t1.daumcdn.net/cfile/tistory/2774164658F1B77811" width=500/>

프로세스 주소 공간에는 다음 4가지 영역으로 이루어져 있다. 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다. 

<img src="https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230324233821814.png" width=200/>

### 스택 영역(stack)

지역 변수, 매개 변수, 반환 값 등 일시적인 데이터를 저장한다. 마찬가지로 변수는 변할 수 있으므로, 읽고 쓰기가 가능하다(rw)

- 함수의 호출과 관계되는 '지역 변수'와 '매개 변수'가 저장
- Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당
- 동적인 특징

### 힙 영역(heap)

동적 할다할 때 사용되며 런타임 시 크기가 결정된다. 동적인 특징을 가지며 

- 런타임에 크기가 결정되는 영역
- 사용자에 의해 공간이 동적으로 할당 및 해제
- 주로 참조형 데이터(ex. 클래스) 등의 데이터가 할당
- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당
- 동적인 특징

### 데이터 영역(BSS segment, Data segment)

전역 변수와 같은 데이터를 관리하는 부분으로, 함수의 바깥에 있는 데이터(전역 변수)를 저장해 놓는다고 보면 된다. 변수는 변할 수 있으므로 읽고 쓰기가 가능하다(rw)

- 전역 변수나 Static 변수 등 프로그램이 사용할 수 있는 데이터를 저장하는 영역
- 프로그램이 종료되면 소멸한다.
- 초기화되지 않은 변수가 존재하면, BSS 영역에 저장된다
- 정적인 특징

### Code Segment(코드 영역) 

프로그램 소스 코드 저장된 부분으로,프로그램의 코드가 바뀌어서는 안되기 때문에 읽기만 가능하다(r)

- 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간
- 프로그램이 수정되면 안되므로 ReadOnly 상태로 저장
- 정적인 특징

<br>

<br>

### 정적 할당

컴파일 단계에서 메모리를 할당하는 것으로, <u>BSS segment</u>와 <u>Data segment</u>, <u>code segment</u>로 나뉘어서 저장된다. BSS segment는 전역 변수, static, const로 선언되어 있는 변수 중 0으로 초기화 또는 초기화가 어떤 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당 된다.

```c
#include <bits/stc++.h>
using namespace std;
int a;
int b = 0;
const int c = 0;
int main()
{
  static int d;
  static int e = 0;
  return 0;
}
```

Data segment는 전역변수, staic, const로 선언되어 있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당 된다.

```c
#include <bits/stc++.h>
using namespace std;
int a = 1;
const int b = 2;
int main()
{
  static int c = 3;
  return 0;
}
```

Code segment에는 프로그램 코드가 들어간다.

### 동적 할당

동적 할당은 런타임 단계에서 메모리를 할당 받는 것으로, Stack과 Heap으로 나눠진다.

Stack은 지역변수, 매개 변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다. 함수가 호출될 때마다 특정 정보가 stack에 계속 저장된다.

Heap은 동적으로 할당되는 변수들을 담는다. `malloc()`, `free()` 함수를 통해 관리할 수 있으며, 동적으로 관리되는 자료구조의 경우 Heap 영역을 사용한다. 예로 `vector`는 내부적으로 heap 영역을 사용한다. 

<br>

그렇다면 왜 이렇게 구역을 나누게 된 걸까?

최대한 데이터를 공유하여 메모리 사용량을 줄여야하기 때문이다.

1. **왜 Code 부분을 따로 두었나?**

프로그램의 코드는 프로그램이 만들어지고 나서는 바뀔 일이 전혀 없다. 따라서 읽기만 가능한 Read Only 부분이고, 그렇기 때문에 같은 프로그램을 실행시켜 여러개의 프로세스가 실행되더라도, 같은 프로그램이라면 Code 부분은 다 똑같은 내용을 가지게 된다. 

2. **왜 Stack 부분과 Data 부분을 나누었나?**

결론부터 말하면, 스택 구조의 특성과 전역 변수의 활용성을 위해서이다. 스택 구조는 다들 잘 알다 싶이 다음 그림과 같은 구조(Last In First Out, LIFO)를 갖고 있다. 따라서 한쪽으로만 데이터를 집어 넣을 수 없고, 꺼낼 때는 최근에 집어넣었던 것부터 꺼낼 수 밖에 없는 구조이다. 

<img src="https://t1.daumcdn.net/cfile/tistory/22102D3958F1BDA40D" width=70/>

다음과 같은 C 언어 코드를 예로 들어보자.

<img src="https://t1.daumcdn.net/cfile/tistory/2174013858F1BED70A" width=500/>

`main` 함수부터 실행이 되고, `printf` 함수가 수행된 뒤, 함수 `func`1을 실행하게 된다. 함수 `func`1이 실행된 후 `main`에서 다시 `printf`가 실행되고 함수 `func2`가 실행된다. 그리고 `func2`에서는 `printf`를 수행하고 `func3`를 실행한다. 이렇게만 설명하면 이해가 안될 수 있는데 다음 그림을 살펴봐보자.

<img src="https://t1.daumcdn.net/cfile/tistory/2630833B58F1C0363A" width=500/>

그림처럼 함수는 Stack 구조로 진행되기 때문에, Data 부분과 Stack 부분을 따로 나누게 된 것이다. 전역 변수는 어떤 함수에서도 접근할 수 있기 때문에 Data로 따로 관리를 해둔다. **어떤 함수에서든 공통으로 사용하는 '전역 변수'를 따로 지정해둠으로써 메모리를 아낄 수 있는 것**이다. 따라서 <u>함수 외부</u>(Outside function)와 함수(Inside function, 지역 변수 포함)에 따라서 Stack 구조 활용을 위해 나누었다고 생각하면 된다. 

<br>

<br>

<br>

<br>

<br><br>

<br>

Reference

- https://whereisusb.tistory.com/7