## 8.1 인터럽트란?

OS는 서로 다른 일을 하는 수많은 하드웨어를 사용한다. 이런 장치들은 동기적으로 구동되는데, 이는 각 각 동작이 완료될 때까지 기다려야하므로 아무것도 하지 않으면서 바쁜 상태로 많은 시간을 소비하게 된다. 이때, 한번에 하나의 명령만 수행할 수 있는 CPU의 한계성을 보완하고 자원을 효율적으로 관리하기 위해 인터럽트라는 방식을 사용한다.

인터럽트는 **CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것**을 말한다.

사용자에 의해서 새로운 프로그램이 실행될 때, 현재 실행 중인 프로세스의 상태를 잠시 중단하고, 새로운 프로그램을 실행시키는 과정이다. 잠시 중단한 프로세스의 상태는 다시 실행을 시작하기 위해 중단되었던 시점의 정보를 잠시 저장한다.

인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.

### 8.1.1 하드웨어/외부 인터럽트

하드웨어가 발생시키는 인터럽트로, 일반적인 인터럽트를 이르는 말이다. CPU가 아닌 다른 하드에어 장치가 CPU에 어떤 사실을 알려주거나 CPU 서비스를 요청해야 할 경우 발생시킨다.

- 전원 이상 인터럽트 : 정전이나 전원이 이상이 있는 경우
- 기계 고장 인터럽트 : CPU등의 기능적인 동작 오류가 발생한 경우
- 입출력 인터럽트(I/O) : 입출력의 종료 등의 이유로 CPU의 수행을 요청하는 인터럽트
- 외부 신호 인터럽트 : I/O 장치가 아닌 오퍼레이터나 타이머에 의해 의도적으로 프로그램이 중단된 경우

### 8.1.2 소프트웨어/내부 인터럽트

소프트웨어가 발생시키는 인터럽트로, 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생한다.

- 프로그램 검사 인터럽트
    - CPU내부에서 실행하면서 인터럽트에 걸리는 경우
        - 0으로 나누는 경우
        - 오버플로우 또는 언더플로우가 발생한 경우
        - 프로그램 상의 오류
        - 프로그램에서 함수 등 명령어를 잘못 사용한 경우
- SVC 인터럽트 === Trap
    - 사용자가 프로그램을 실행시키거나 supervisior(OS)을 호출하는 동작을 수행하는 경우
    - 프로그래머에 의해 코드로 짜인 감시 프로그램을 호출하는 방식

## 8.2 인터럽트 과정

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Ftgbjf%2FbtrdwTgIwQi%2F8SNWaNk0UEtxiJZYVNxKvK%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Ftgbjf%2FbtrdwTgIwQi%2F8SNWaNk0UEtxiJZYVNxKvK%2Fimg.png)

어떤 특정 프로그램이 실행되고 있다고 가정했을 때, 다른 프로세스를 처리하기 위해 인터럽트가 발생한다. 만약 인터럽트가 발생하면 운영체제가 제어권을 받는다. 운영체제는 현재 운영하고 있는 프로그램을 Micro Operation까지 수행 후 중단하고 인터럽트 받은 현재의 프로세스 상태를 해당 프로세스의 PCB에 저장한다. 그 후 운영체제는 인터럽트의 발생 원인을 찾아 인터럽트 백터를 읽어 지정되어 있는 ISR로 제어권을 넘겨준다. 그 다음 인터럽트 처리 루틴이 실질적인 작업을 수행한다. 수행 중 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 다시 요청-중단-보관-처리 과정을 수행한다. 해당 작업을 다 처리하면 ISR 끝에 RETI 명령어에 의해 인터럽트가 해제된다. 그 후 인터럽트가 걸렸던 이전 프로세스의 상태로 복구된다. 그리고 마지막으로 인터럽트가 걸렸던 시점 이후부터 프로세스가 실행된다.

1. 인터럽트 요청
2. 프로그램 실행 중단
    1. 현재 실행중이던 Micro Operation까지 수행
3. 현재 실행중인 프로그램 상태 보관
    1. 현재까지 수행중이었던 상태를 해당 프로세스의 PCB에 저장
    2. PC에 다음 실행할 명령의 주소 저장
    3. Interrupt Vector를 읽어 ISR 주소값을 얻음
        - 인터럽트 백터
            
            인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 자료구조
            
            인터럽트 요청이 발생했을 때, CPU는 인터럽트 소스가 무엇이며, 해당 인터럽트 ISR이 어디에 적재되어있는지를 확인해야한다. 이 때,  인터럽트 백터를 활용한다.
            
            인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴(Interrupt Service Routine) 또는 인터럽트 핸들러라고 불리는 다른 곳에 정의된다.
            
        - ISR
            
            인터럽트 서비스 루틴, 인터럽트 핸들러라고도 함
            
            인터럽트가 접수되면 각각의 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴
            
    4. ISR로 점프 (이 때, PC 값은 자동 대피 저장됨)
    5. 현재 진행중인 프로그램의 레지스터를 대피함
4. 인터럽트 서비스 루틴 처리
    1. 인터럽트 원인을 파악하고 실질적인 작업 수행
    2. 서비스 루틴 수행 중, 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1-5 과정 수행
5. 상태 복구
    1. 해당 작업을 다 처리하면, 대피시킨 레지스터를 복원
    2. ISR 끝에 RETI 명령어에 의해 인터럽트 해제
    3. 명령어가 실행되면, PC 값을 복원하여 이전 실행 위치로 복원

![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcsOicV%2FbtrcebCFFGo%2FJOr4V3M4umegWKsqdtSV8K%2Fimg.jpg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcsOicV%2FbtrcebCFFGo%2FJOr4V3M4umegWKsqdtSV8K%2Fimg.jpg)

## 8.3 우선순위

**인터럽트 처리 중 또 다른 인터럽트가 발생한다면?** 

하나의 인터럽트를 처리중인 경우에 원칙적으로는 또 다른 인터럽트의 처리를 허용하지 않는다. 인터럽트가 발생해서 운영체제 커널에 정의된 데이터를 변경하고 있는 상황에 또다른 인터럽트가 발생해서 같은 데이터를 수정하게 되면 의도하지 않은 결과값으로 바뀔 수 있기 때문이다. 그러나 예외적인 경우가 존재한다. 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트가 발생하면 인터럽트를 허용한다. 이 때는 현재 처리 중이던 인터럽트 코드의 수행 지점을 커널 스택에 저장한 뒤, 우선적으로 처리할 인터럽트를 처리한 뒤, 이전에 실행 중이던 인터럽트 코드 부분으로 되돌아와 남은 부분을 처리하게 된다.

### 8.3.1 인터럽트 우선순위

- 전원 이상 인터럽트
- 기계 고장 인터럽트
- 외부 신호 인터럽트
- 프로그램 인터럽트
- SVC

### 8.3.2 우선순위 판별 방법

- 폴링 Polling
    - 가장 높은 인터럽트로부터 요청 플래그를 검사하여 ISR을 수행하는 소프트웨어적인 방법
    - 인터럽트를 조사하는 비용이 들어 반응시간이 느리지만, 하드웨어를 추가할 필요가 없어 회로가 간단하다.
- 데이지 체인 Daisy Chain
    - 어디에 인터럽트가 발생하는지 확인하는 회로를 직렬로 연결하는 하드웨어적인 방법

## ~~8.4 특권 명령~~

### ~~8.4.1 명령어의 종류~~

- ~~일반 명령~~
    - ~~메모리에서 자료를 읽어오고, CPU에서 계산을 하는 등의 명령~~
    - ~~모든 프로그램이 수행할 수 있는 명령~~
    - ~~User Mode와 Kernel Mode~~
- ~~특권 명령~~
    - ~~보안이 필요한 명령~~
    - ~~입출력 장치, 타이머 등의 장치를 접근하는 명령~~
    - ~~운영체제만이 수행 가능~~

## QUIZ

- **Q. 인터럽트란 무엇인가요?**
    
    인터럽트란 프로세스 실행 중에 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알려 처리할 수 있도록 하는 것을 말합니다.
    
    폴링은 대상을 주기적으로 감시하여 상황이 발생하면 해당 루틴을 처리합니다.
    
    인터럽트란 CPU가 프로그램을 실행하고 있는 도중에 입출력 요청 또는 예외상황을 처리해야 하면 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 말합니다. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 구성되어 있습니다. 하드웨어 인터럽트는 하드웨어 기기가 인터럽트를 요청하는 것이고 소프트웨어 인터럽트는 예외처리, 시스템 콜이 발생하는 상황에서 실행됩니다.
    
- **Q. 운영체제한테 CPU가 넘어가는 경우는 언제인가?**
    1. 하드웨어 장치들에 의해 인터럽트를 거는 경우
    2. 소프트웨어들이 스스로 인터럽트를 거는 경우 (system call)
    3. 권한이 없는 기계어를 실행하려는 경우
    4. exception이 발생하는 경우
- **Q. 인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?**
    
    1. 원칙적으로는 인터럽트 처리중에 또 다른 인터럽트의 처리를 허용하지 않는다.
    
    - 앞서 변경중이던 데이터를 또다른 인터럽트가 발생해 처리하게 되면 의도하지 않은 결과값으로 바뀔 수 있기 때문이다.
    
    2. 예외적인 경우가 존재한다.
    
    - 인터럽트마다 중요도가 다르다.
    - 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트 발생을 허용한다.

## Reference

[https://velog.io/@adam2/인터럽트](https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)

[https://velog.io/@hyun0310woo/7.-운영체제-인터럽트에-대해서](https://velog.io/@hyun0310woo/7.-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)

[https://overcome-the-limits.tistory.com/134](https://overcome-the-limits.tistory.com/134)

[https://doh-an.tistory.com/31](https://doh-an.tistory.com/31)

[https://hibee.tistory.com/264](https://hibee.tistory.com/264)

[https://primayy.tistory.com/43](https://primayy.tistory.com/43)
