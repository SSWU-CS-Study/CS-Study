# 6. [운영체제] Process


<aside>

📌 **`면접 예상 질문`**

- **프로세스의 정의**
    - 프로세스란 실행되고 있는 프로그램이며 메모리에 올라간 프로그램 이다 .
- **프로세스의 문맥 (context) 란 무엇인지?**
    - 문맥이란 프로세스의 메모리를 비롯해 CPU에 저장된 정보들을 포함한 것이며 크게 하드웨어 문맥, 프로세스의 주소 공간, 커널 자료구조로 나뉜다.
- **프로세스 문맥이 왜 필요한 것인지 ?**
    - 프로세스가 실행되어서 종료될 때 까지 항상 CPU에서 여러 프로세스들이 자주 CPU를 빼앗고 획득하기 때문에 다시 이를 획득해 명령의 수행을 재개하는 시점이 되면 어느 부분까지 명령을 수행했는지 알기 위해 프로세스의 상태를 재현할 필요가 있기 때문
- **Context Switch 란?**
    - 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권을 넘겨주는 과정으로, CPU의 현재 상태, 프로세스의 현재 상태들을 모두 정리하여 PCB에 저장한 후 캐시 메모리를 비우는 작업이 진행된다.
- ****System call이 발생하면 context switch일까?****
    - **한 프로세스에서 다른 프로세스**로 넘기는 과정을 문맥 교환이라고 하기 때문에, 단순히 커널 함수를 처리하고(시스템 콜로 인해) 해당 프로세스로 복귀한다면 문맥 교환이라고 하지 않는다.
- **프로세스의 상태는 어떻게 나뉘는가?**
    - 프로세스는 실행, 준비, 봉쇄, 중지, 시작, 완료 의 상태로 구분할 수 있다
- **PCB란?**
    - 운영 체제가 프로세스들을 관리하기 위해 각 프로세스들의 정보를 담는 커널 내의 자료구조
- **프로세스 스케줄링이란**
    - 프로세스 스케줄러란 어떤 프로세스에게 CPU를 할당할지를 결정하는 운영 체제 함수를 의미하며 장기, 중기, 단기 스케쥴러로 나뉜다.
</aside>

# Process

> 프로세스란 실행되고 있는 프로그램이다.
> 

프로그램은 보조기억장치에 저장돼있는 코드 덩어리이며, 프로세스는 메모리에 올라간 프로그램이다.
보조기억장치에 실행 파일 형태로(exe, jar 등) 존재하던 프로그램이 메모리에 올라가면 비로소 CPU를 할당받을 수 있는 자격을 얻게된다.

## ****프로세스의 문맥(context)****

프로세스가 실행돼서 종료될 때까지 항상 CPU에서 명령을 처리하면 좋겠지만, 여러 프로세스가 함께 수행되는 시분할 환경에서는 각 프로세스들이 CPU를 자주 빼앗기고 획득하게 된다.

따라서 CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면, CPU를 빼앗기기 전에 어느 부분까지 명령을 수행했는지 정확한 프로세스의 상태를 재현할 필요가 있다.

이때 정확한 재현을 위해 필요한 정보가 바로 프로세스의 `문맥(Context)`이다.

즉, 프로세스의 문맥은 프로세스의 메모리(Stack, Data, Code)를 비롯해 CPU 레지스터에 저장된 데이터, 시스템 콜을 통해 커널에서 수행한 작업들의 현황, 프로세스에 대해 커널이 관리하고 있는 각종 정보 등을 포함하게 된다. 프로세스의 문맥은 3가지로 나눌 수 있다.



1. `하드웨어 문맥`
    
    프로세스에 대한 CPU 수행 상태를 나타내는 것은 하드웨어 문맥이라고 부르며 각종 레지스터를 일컫는다.
    
    어디까지 실행했는가? → Program Counter
    
    어떤 논리로 처리해야 하는가? → ALU(arithmetic logic unit)
    
2. `프로세스의 주소 공간`
    
    프로세스가 가지고 있는 코드와 데이터, 그리고 로직을 수행하는 스택
    
3. `프로세스 관련 커널 자료구조`
    1. **PCB(Process Control Block)**:  프로세스의 상태에 대한 데이터가 담겨있는 자료구조
    2. **커널 스택(Kernel stack)**:  프로세스가 커널(OS 코드)를 호출 했을 때, 해당 메서드가 실행되는 프로세스만의 스택
    다른 프로세스도 OS를 호출 할 것이기 때문에, 서로 섞이고 꼬이는 것을 방지하기 위해 각 프로세스마다 고유한 커널 스택이 있다.
    

## **프로세스의 상태**

> 프로세스의 상태는 계속해서 변경된다.
> 
- 실행 ****Running****
    - CPU를 잡고 instruction을 수행중인 상태
- 준비 ****Ready****
    - CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
- 봉쇄 ****Blocked (wait, sleep)****
    - 메모리에 프로그램이 올라가 있지만, CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태
    - 프로세스가 요청한 이벤트(I/O 등)가 완료 되지 않아 이를 기다리는 상태
    - Swap 공간에 있는 메모리에 접근할 때도 Blocked가 된다! (디스크에서 파일을 읽어와야 하는 경우이므로)
- ****Suspended (stopped)****
    - 외부적인 이유로 프로세스의 수행이 정지된 상태
    - 프로세스는 통째로 디스크에 Swap out 된다.
    - 사용자가 프로그램을 일시정지(break key) 시키거나, 시스템에 메모리에 너무 많은 프로세스가 올라와 있어 프로세스를 잠시 중단시킨 경우
- **시작 New**
    - 프로세스가 생성중인 상태
- **완료 Terminated**
    - 수행(execution)이 끝난 상태
    



suspend와 커널모드 내용이 추가된 상태변화도

- 프로세스가 생성되면 `New` 에서 `Ready` 가 된다.
- `Ready` 에서 CPU를 할당받으면 `Running` 이 된다.
- CPU 얻은 상태에서 내려 놓는 경우
    - `Running` → `Terminated` : 본인의 역할을 다하면 종료됨
    - `Running` → `Waiting` : I/O 같은 작업을 하면, CPU가 `Blocking` 되어 명령을 수행할 수 없으므로 `Waiting` 이 된다.
    - `Running` → `Ready` : `Timer`에 지정 된 CPU 사용시간이 끝나면 `Ready` 가 된다.

## **Process Control Block (PCB)**

> 운영 체제가 프로세스들을 관리하기 위해 각 프로세스들의 정보를 담는 커널 내의 자료구조
> 


- 프로그램 카운터(program counter)
    
     프로세스가 다음에 실행할 명령어의 주소를 나타낸다.
    
- CPU 레지스터들
    
    컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
    
    프로그램 카운터 + 상태정보는 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 업데이트 
    
- CPU 스케줄링 정보
    
    프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함
    
- 메모리 관리 정보
    
    운영체제에 의해 사용되는 메모리 시스템에 따라 기준(base) 레지스터와 한계(limit)레지스터의 값, 페이지 테이블, 세그먼트 테이블 등과 같은 정보를 포함
    
- accounting 정보
    
    CPU 사용 시간과 경과된 실시간, 시간제한, 계정 번호, 잡 또는 프로세스 번호 등을 포함
    
- 입출력 상태 정보
    
    프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.
    

## Context Switch **문맥 교환**

> CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
> 

`문맥 교환`이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권을 넘겨주는 과정으로, CPU의 현재 상태, 프로세스의 현재 상태들을 모두 정리하여 PCB에 저장한 후 캐시 메모리를 비우는 작업이 진행된다. CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.

사용자 프로세스가 CPU를 할당 받고 실행되던 중에 타이머 인터럽트가 발생하면 CPU의 제어권이 운영체제에게 넘어가게 된다.

운영 체제는 ISR을 통해 타이머 인터럽트 처리를 시작하며, 직전까지 수행 중이던 프로세스의 모든 상태를 PCB에 저장하고 `Ready` 상태의 프로세스에게 CPU의 제어권을 넘긴다.

이 과정에서 원래 수행 중이던 프로세스는 `Running`->`Ready`등의 상태로 바뀌고 새롭게 CPU를 할당 받은 프로세스는 `Ready`->`Running` 상태가 된다.

문맥 교환 중 원래 CPU를 할당받았던 프로세스는 자신의 모든 상태를 자신의 PCB에 저장하고, 새롭게 CPU를 할당 받은 프로세스는 예전에 저장했던 자신의 상태를 자신의 PCB로부터 불러오는 과정을 거친다.


❓ ****System call이 발생하면 context switch일까?****

시스템 콜이나 인터럽트가 발생 시 반드시 context switch가 일어나는 것은 아니다.

위에서 서술했듯이 **한 프로세스에서 다른 프로세스**로 넘기는 과정을 문맥 교환이라고 하기 때문에, 단순히 커널 함수를 처리하고(시스템 콜로 인해) 해당 프로세스로 복귀한다면 문맥 교환이라고 하지 않는다.


컨텍스트 스위칭은 단순 커널모드 진입보다 비용이 훨씬 크다

</aside>

## **프로세스 스케줄링**

> 프로세스 스케줄러란 어떤 프로세스에게 CPU를 할당할지를 결정하는 운영 체제 함수를 의미한다.
> 

 프로그래밍에서 중요한 것은 프로세스들 사이에서 CPU를 빈번하게 교체하는 것이다. **프로세스 스케줄러**는 실행가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. CPU 코어는 **한 번에 하나의 프로세스**를 실행할 수 있다. 만약 코어가 여러개라면 한 번에 여러개의 프로세스를 실행할 수 있다. 코어 수 보다 더 많은 프로세스가 있는 경우 초과 프로세스는 코어가 다시 사용 가능해지고 스케줄 될 때 까지 기다려야 한다.

### 스케줄러의 종류

- **Long-Term Scheduler (장기 스케줄러 or Job scheduler)**
    - `New` 상태의 프로세스들 중 어떤 것들을 `Ready Queue`로 보낼지 결정한다.
    - 프로세스에 메모리를 할당하는 문제에 관여한다.
    - `degree of Multiprogramming`을 제어. 메모리에 프로세스가 10개 올라가있다면 `degree of Multiprogramming` 는 10이다.
    - `degree of Multiprogramming`이 너무 낮아도 CPU 효율이 제대로 안나오고(CPU가 놀아서), 너무 높아도 효율이 안나온다(컨텍스트 스위칭 등).
    - 현대의 시분할 시스템에는 보통 장기 스케줄러가 없다. `New` 상태의 프로세스는 전부 `Ready Queue`에 삽입한다.
- **Medium-Term Scheduler (중기 스케줄러 or Swapper)**
    - 메모리 여유 공간 마련을 위해 프로세스를 통째로 디스크의 스왑 영역으로 밀어낸다. (Swap Out)
    - 장기 스케쥴러가 없는 시스템(현대의 컴퓨터 시스템)에서 `degree of Multiprogramming`을 제어
    - 주로 `Blocked` 상태에 있는 프로세스들을 `Swap out`하고, 그래도 메모리 공간이 부족하면 `Ready Queue` 후반부에 있는 프로세스들을 `Swap out`한다.
- **Short-Term Scheduler (단기 스케줄러 or CPU scheduler)**
    - 어떤 프로세스를 다음 번에 `Running` 할지 결정
    - 프로세스에 CPU를 주는 문제
    - 충분히 빨라야 한다. (ms 단위)
