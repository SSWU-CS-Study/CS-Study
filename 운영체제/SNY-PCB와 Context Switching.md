# PCB와 Context Switcing

<br>
<br>

## Process Management

프로세스 관리(process management)란, CPU **프로세스가 여러개일 때, CPU 스케줄링을 통해 관리하는 것**을 말한다.

이때, CPU는 각 프로세스들이 누군지 알아야 관리가 가능하고, **프로세스들의 특징**을 갖고 있는 것이 바로 `Process Metadata` 이다.

### Process Metadata

- Process ID(PID) : 프로세스의 고유 번호
- Process State : 준비, 대기, 실행 등의 상태
- Process Priority
- CPU Registers
- CPU Usage
- Memory Usage

이러한 **메타데이터는** 프로세스가 생성되면 **PCB(Process Control Block)라는 곳에 저장**된다.

<br>

<br>

## PCB(Process Control Block)

운영체제가 프로세스를 제어하기 위해 정보(메타데이터)를 저장해 놓는 곳으로, **한 PCB 안에는 한 프로세스의 정보**가 담긴다.

프로세스의 상태 정보를 저장하는 구조체(자료구조)라고 할 수 있다.

<img src="https://t1.daumcdn.net/cfile/tistory/25673A5058F211C224" width=500/>

운영체제에서 프로세스는 PCB로 표현된다. 

프로그램이 실행되는 것부터 PCB에 저장되기까지의 일련의 과정을 살펴보면 다음과 같다.

```
프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 (코드, 데이터, 스택) 생성 -> 이 프로세스의 메타데이터들이 PCB에 저장
```

<br>

OS에 따라 PCB에 포함되는 항목이 다를 수 있지만, 일반적으로 포인터, 프로세스 상태, 프로세스 번호, 프로그램 카운터, 레지스터, 메모리 제한, 열린 파일 목록 등이 있다. 이는 프로세스 상태 관리와 Context Switching을 위해 필요하다.

OS는 빠르게 PCB에 접근하기 위해 프로세스 테이블을 사용해 각 프로세스의 PCB를 관리한다. 

<br>

### PCB의 필요성

**그렇다면 PCB는 왜 필요할까?**

CPU에서는 **프로세스의 상태에 따라 교체작업**이 이루어진다. 만약 어떤 프로세스로부터 **인터럽트가 발생**해서, 현재 프로세스가 잠시 대기 상태가 되고, 인터럽트가 발생된 프로세스를 실행 상태로 바꿔치기 할 때, **대기 중인 프로세스의 정보를 잃어버리게 되면 프로그램을 처음부터 다시 시작**해야 한다. 이렇게 되면 사용자 입장에선 당혹스러울 것이다.

<br>

따라서, 대기하다가 다시 실행할 때 **대기 상태로 바뀌기 직전의 실행 정보를 고스란히 저장**해둔다면, 다시 실행 상태로 돌아왔을 때 아무 일도 없었단 듯이 흘러갈 수 있을 것이다. 이 동작을 위해 PCB가 필요한 것이다. 

>  정리하자면, 프로세스 A에서 B로 교체될 때 아래와 같은 과정이 일어나게 된다.
>
> 1. B에서 인터럽트 발생
> 2. A의 현재 실행 정보를 PCB에 저장
> 3. A를 대기 상태로 돌리고 B를 실행 상태로 전환
> 4. B의 PCB 정보를 기반으로 실행 재개
> 5. B가 원하는 동작을 모두 수행함
> 6. B의 현재 실행 정보를 PCB에 저장
> 7. B를 대기 상태로 돌리고 A를 실행 상태로 전환
> 8. A의 PCB 정보를 기반으로 실행 재개

<br>

### PCB의 관리 방식

**PCB는 어떻게 관리될까?**

**한 프로세스에 한 PCB가 생성**된다. 따라서 PCB는 프로세스가 생성될 때마다 하나씩 늘어나게 되는데, 이때 PCB 들을 관리하는 자료구조는 바로 **Linked List 형태**이다. PCB List Head에 PCB들이 생성될 때마다 하나씩 이어붙게 된다. 주소값으로 연결되는 형태이기 때문에 새로운 녀석이 들어오거나, 기존의 녀석이 나갈 때 뛰어난 효율을 보이게 된다. (삽입/삭제에 용이한 연결 리스트의 특성 활용)

정리하자면, **프로세스가 생성될 때마다 고유 PCB가 생성되고, 프로세스가 완료되면 PCB도 함께 제거**된다. 

<br>

<br>

## Context Switching

앞서 프로세스를 교체하는 예시를 들었는데, 이처럼 프로세스를 교체하는 행위 자체를 **Context Switching**이라고 한다. 원래 **실행 중이던 프로세스의 상태를 PCB에 보관하고, 새로 들어오는 프로세스의 PCB 정보를 바탕으로 레지스터에 값을 적재하는 과정**을 일컫는 말이다. 

일반적으로 <u>인터럽트 발생</u> 혹은 현재 프로세스의 <u>선점 허용 기간(CPU 사용 허가시간, Time Quantum)을 모두 소모</u>한 상황, <u>입출력을 위해 대기</u>하는 경우에 Context Switching이 발생하게 된다.

>  즉, `Ready` -> `Running` , `Running` -> `Ready` , `Running` -> `Waiting` 처럼 상태 변경 시 발생

<br>

### Context Switching Overhead

Context Switching을 하는 동안에는 CPU가 아무것도 하지 못하게 된다. (CPU가 유휴상태에 들어간다) 따라서, 만일 쓰레드 및 프로세스의 개수가 엄청 많아져 Context Switching이 빈번히 일어나게 된다면, 오버헤드가 잦아져 성능이 악하될 가능성도 있다. 이를 Context Switching Overhead라고 한다. 

그러나 Overhead를 감수하면서 Context Switching을 작동시키는 것이 CPU를 가장 효율적으로 사용하는 방법이다. 

<br>

<br>

<br>

<br>

<br>

<br>













Reference

- https://velog.io/@haero_kim/PCB-%EC%99%80-Context-Switching-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

