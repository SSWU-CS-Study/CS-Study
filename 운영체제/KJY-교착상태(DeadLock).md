## 9.1 데드락, 교착상태란?

<aside>
💡 시스템 자원에 대한 요구가 뒤엉킨 상태, 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

</aside>

[!https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxVu3c%2FbtrEc3xU5u8%2F4zLX6it423piByeKW3SJLk%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxVu3c%2FbtrEc3xU5u8%2F4zLX6it423piByeKW3SJLk%2Fimg.png)

## 9.2 발생조건

---

교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립할 때 발생한다.

- **상호배제**
    - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있음
    - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함
- **점유대기**
    - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함
- **비선점**
    - 이미 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
- **순환대기**
    - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함

그러나, 교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니다.

## 9.3 해결방법

---

- 데드락이 발생하지 않도록 예방하기 prevention
- 데드락 발생 가능성을 인정하면서도 적절하게 회피하기 avoidance
- 데드락 발생을 허용하지만 데드락을 탐지 detection하여, 회복하기 recovery
- 데드락에 아무런 조치를 취하지 않는 무시하기

### 9.3.1 데드락 예방 Prevention

교착상태가 애초에 일어나지 않도록 방지하는 방법으로 데드락의 발생조건 4가지 중 하나를 부정함으로써 예방하는 방법이다.

- 자원의 상호배제 조건 방지
    - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 함
    - 그러나, 추후 동기화 관련 문제가 발생할 수 있음
- 점유 대기 조건 방지
    - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 함
- 비선점 조건 방지
    - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 함
- 순환 대기 조건 방지
    - 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 함

그러나 이러한 조건을 방지해서 데드락을 예방하는 방법은 시스템의 처리량이나 자원 사용의 효율성을 떨어트리는 단점이 있다.

### 9.3.2 데드락 회피 Avoidance

데드락 회피방법은 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않고 안전한 상태에서만 자원 요청을 허용하는 방법이다. 

- 안전 순서 safe sequence
    
    교착상태를 발생시키지 않고 자원을 할당하는 순서
    
- 안전상태 safe state
    
    안전 순서가 존재하며 모든 프로세스가 정상적으로 종료될 수 있는 상태
    
- 불안정 상태 unsafe state
    
    교착상태가 발생할 가능성이 있는 상태
    

데드락 예방법보다는 조금 덜 제한적인 방법으로 예방법의 단점을 일부 해결 가능하지만 아래와 같은 가정이 필요하다.

- 프로세스 수 고정
- 자원의 종류와 수 고정
- 프로세스가 요구하는 최대 자원의 수를 알아야 함
- 프로세스는 자원 사용 후 반드시 반납

회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다. 이러한 특징을 살린 알고리즘으로 유명한 것이 **은행원 알고리즘**이다.

- **은행원 알고리즘**
    
    다익스트라가 제안한 기법으로, 은행에서 모든 고객의 요구를 충족할 수 있도록 현금을 대출해주는 것에서 유래했다. 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 예상되는 모든 자원의 최대 할당량을 가지고 시뮬레이션하여 안전상태에 들 수 있는지 여부를 검사하여 교착상태의 가능성을 미리 조사하는 알고리즘이다. 
    
    ~~기본 개념 자체는 ‘CPU는 최소한 하나의 프로세스에게 할당해줄 만큼의 자원을 항상 보유하고 있어야 한다’이다.~~
    
    시스템이 총 12개의 자원을 가지고 있다고 가정한다.
    
    | (t=t0) | Max | Allocation | Need | Available |
    | --- | --- | --- | --- | --- |
    | P0 | 10 | 5 | 5 |  |
    | P1 | 4 | 2 | 2 |  |
    | P2 | 9 | 2 | 7 |  |
    
    P0~P2는 프로세스이고, Max는 각 프로세스마다 최대 자원 요청량, Allocatoin은 현재 프로세스에 할당 중인 자원의 양, Need는 남은 필요한 자원의 양(Max-Allocation)이다.
    
    현재 t0일 때 프로세스에 할당된 자원의 합은 5+2+2=9개이다. 따라서 현재 Available 자원은 12-9=3이다.
    
    - 남은 가용자원 3개를 P1에게 할당 → 현재 Available = 3-2=1개
    - P1의 작업이 끝나고 할당되어 있던 자원 4개 반납 → 현재 Available = 1+4 = 5개
    - 남은 가용자원 5개를 P0에게 할당 → 현재 Available = 5-5 = 0개
    - P0의 작업이 끝나고 할당되어 있던 자원 10개 반납 → 현재 Available = 0+10 = 10개
    - 남은 가용자원 10개 중 7개를 P2에게 할당 → 현재 Available = 10-7 =3개
    - P2의 작업이 끝나고 할당되어 있던 자원 9개 반납 → 현재 Available = 3+9 =12개
    
    이렇게 <P1, P0, P2>일 때 안전 순서를 만족한다.
    
    ~~만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면 운영체제가 가지고 있는 Available 자원은 12-(5+2+3) = 2개 였을 것이다.~~
    
    ~~이 상황에서는 처음에 P1에게 2개를 모두 주고, P1의 실행이 끝나고 자원을 모두 반납해도 Available 자원은 2+2=4개 뿐이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없었을 것이다.~~
    
    ~~따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것이다.~~
    
    ~~운영체제게 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끝나게 한다면 데드락이 발생하지 않았을 것이다. 그러므로 은행원 알고리즘을 사용해서 자원 할당량을 사전에 파악하고 데드락을 회피할 수 있다.~~
    
    그러나 은행원 알고리즘의 경우, 이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약 조건이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재한다.
    
    이처럼 교착상태 회피 방법의 가장 큰 문제는 문제 발생에 대한 일관성과 가정이 완벽할 것이라는 것을 보장하기가 현실적으로 어렵다는 점이다. 시스템의 규모가 작은 운영체제라면 고려해볼 만한 방법이지만, 멀티 리소스, 멀티 프로세스의 복잡한 운영체제 환경에서는 자원 할당 그래프를 분석하면서 안전 상태를 파악하기가 상당히 어렵다.
    
- **자원 할당 그래프 알고리즘**
    
    자원 할당 그래프에 예약 간선을 추가하여 예약 간선으로 설정한 자원에 대해서만 자원 할당을 요청할 수 있고 사이클이 형성되지 않을 때만 자원을 할당받는 방법
    
    - 자원 할당 그래프
        
        프로세스가 어떤 자원을 사용 중이고, 어떤 자원을 기다리는지 방향성 있는 그래프로 표시한 것
        
    - 예약 간선
        
        향후 요청할 수 있는 자원을 가리키는 점선으로 표시된 간선
        

### 9.3.3 데드락 탐지

시스템에 데드락이 발생했는지에 대한 여부를 탐색하고 회복 기법 알고리즘에 활용하는 것을 의미한다. 교착상태가 탐지되었다면 회복 기법을 통해 교착 상태를 복구한다.

그러나 탐지 기법은 지속적으로 교착 상태를 확인하는 작업이 필요하기 때문에 오버헤드가 발생하게 된다.

- Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
- 이 외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.
- 자원 할당 그래프
    
    [!https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2745A63A5714C38329](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2745A63A5714C38329)
    
    - 프로세스Pi로부터 자원 Rj로의 방향 간선은 Pi→Rj로 표현하며 이것은 프로세스 Pi가 자원Rj를 요청하는 것으로 현재 이 자원을 기다리는 상태
    - 자원 Rj로부터 프로세스 Pi로의 방향 간선은 Rj→Pi로 표현하며 이것은 자원이 프로세스 Pi에 이미 할당된 것을 의미
    - 자원을 요청할 때마다 탐지 알고리즘을 실행하면 그에 대한 오버헤드가 발생한다.
    

### 9.3.4 데드락 회복

데드락을 탐지 기법을 통해 발견했다면, 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법을 사용한다.

- 프로세스 중지
    - 교착 상태에 빠진 모든 프로세스를 중단시키는 방법
        - 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
    - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법
        - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담 가중
- 자원 선점
    - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법
    - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

### 9.3.5 데드락 무시

교착상태의 필요조건 네 가지를 모두 만족하더라도 교착상태가 반드시 일어나는 것이 아니라고 했듯이, 교착상태는 매우 드문 상황이다. 그러므로 이를 위해 오버헤드를 감수하는 것이 비효율적인 환경도 존재한다. 그러한 환경은 교착상태에 대한 아무런 조치를 하지 않는 방법도 있다. 현재 채택하고 있는 방법이다.

## QUIZ

- 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요
    
    멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황입니다. 데드락이 발생하기 위한 조건으로는 상호배타, 점유 대기, 비선점, 순환대기가 있습니다.
    
- 상호배제, 점유대기, 비선점, 순환대기에 대해 간략하게 설명해 보세요
    
    데드락이 발생하기 위한 조건으로, 한 번에 프로세스 하나만 자원을 사용할 수 있는 상호배타, 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 하는 점유 대기, 이미 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없는 비선점, 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 하는 순환대기입니다.
    
- 회피 기법인 은행원 알고리즘이 무엇인지 설명해보세요.
    
    어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 예상되는 모든 자원의 최대 할당량을 가지고 시뮬레이션하여 안전상태에 들 수 있는지 여부를 검사하여 교착상태의 가능성을 미리 조사하는 알고리즘입니다.
    
- 데드락 상태를 해결하기 위한 방법은 무엇이 있나요?
    
    데드락이 발생하지 않도록 예방하기 prevention, 데드락 발생 가능성을 인정하면서도 적절하게 회피하기 avoidance, 데드락 발생을 허용하지만 데드락을 탐지 detection하여, 회복하기, 아무런 조치를 하지 않는 무시 방법이 있습니다.
    
- 기아상태를 설명하는 **식사하는 철학자** 문제에 대해 설명해 보세요 OR 알고있는 교착상태 예시를 하나 말해주세요 (뮤텍스와 셰마포어 연관 질문)
    
    철학자 다섯 명이 원형 식탁에 앉아 밥을 먹으려고 합니다. 그들의 양쪽엔 각각 젓가락 한 짝씩 놓여 있고, 밥을 먹으려 할 땐 다음의 과정을 따릅니다.
    
    <aside>
    💡
    
    1. 왼쪽 젓가락부터 집어 듭니다. 다른 철학자가 이미 왼쪽 젓가락을 쓰고 있다면 그가 내려놓을 때까지 대기합니다.
    2. 왼쪽을 들었으면 오른쪽 젓가락을 듭니다. 들 수 없다면 대기합니다.
    3. 두 젓가락을 모두 들었다면 일정 시간 동안 식사를 합니다.
    4. 식사를 마쳤으면 오른쪽 젓가락을 내려 놓은 후 왼쪽 젓가락을 내려놓습니다.
    5. 다시 배고프면 1번부터 진행합니다.
    </aside>
    
    철학자는 프로세스, 젓가락은 자원으로 가정한 후 모든 철학자가 왼쪽 젓가락을 들은 상황을 가정해봅시다. 그렇다면 **모든 철학자는 오른쪽 젓가락을 집기 위해 대기하는 교착상태가 발생**합니다. 조금 더 자세하게 교착상태 발생의 4가지 필요충분조건을 만족하는지 확인해보겠습니다.
    
    <aside>
    💡 상호 배제 -> 젓가락은 한 번에 한 철학자만 사용할 수 있습니다.
    
    점유 대기 -> 왼쪽 젓가락을 점유하면서 오른쪽 젓가락을 대기합니다.
    
    비선점 -> 이미 누군가가 집어 든 젓가락을 강제로 뺏을 수 없습니다.
    
    환형 대기 -> 모든 철학자들이 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다립니다.
    
    </aside>
    

## Reference

[https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html)

[https://chanhuiseok.github.io/posts/cs-2/](https://chanhuiseok.github.io/posts/cs-2/)

[https://jwprogramming.tistory.com/12](https://jwprogramming.tistory.com/12)

[https://cocoon1787.tistory.com/858](https://cocoon1787.tistory.com/858)

[https://gona.tistory.com/47](https://gona.tistory.com/47)
