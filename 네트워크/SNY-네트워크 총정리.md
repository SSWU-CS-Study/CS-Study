# 네트워크 총정리

<br>
<br>

## OSI 7계층

네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 **OSI 7계층**이라 한다.

<img src="https://camo.githubusercontent.com/44fe40125073c05a22961a70ae08c4e0b6b2bf5bfbd11f5ab9135e2a683241a7/68747470733a2f2f73373238302e7063646e2e636f2f77702d636f6e74656e742f75706c6f6164732f323031382f30362f6f73692d6d6f64656c2d372d6c61796572732d312e706e67" width=400 />

이와 같이 7계층으로 나누는 이유?

- 통신이 일어나는 과정을 단계별로 알 수 있다
- 각각의 계층은 독립적이기 때문에, **변경이나 업데이트가 필요할 때 각각의 계층만 수정**하면 되므로 **유지보수나 개발이 용이**하다

<br>

1층에서 7계층으로 갈수록 점점 헤더(header)를 붙여 data가 늘어나고, 캡슐화(encapsulation)된다. 

### 1) 물리 계층

- 데이터를 전기적인 아날로그 신호로 변환해서 주고 받는 기능을 하는 계층 (비트 단위)
- 단지 데이터 전달만 할 뿐, 받으려는 데이터가 무엇인지 어떤 에러가 있는지 등에는 신경 쓰지 않는다
- ex) 리피터, 케이블, 허브, LAN 카드

### 2) 데이터 링크 계층

- 물리 계층으로 송수신 되는 정보를 관리하여, 안전하게 전달될 수 있도록 도와주는 역할
- MAC 주소를 이용하여 컴퓨터들을 구별
- 물리 계층의 비트를 프레임(frame)이라는 논리적 단위로 정리하고, 에러 검출과 재전송 기능을 통해 신뢰성있는 데이터 전송을 보장
- ex) 브릿지, 스위치

### 3) 네트워크 계층

- 서로 다른 네트워크 간에 패킷을 전송하는 역할
- 라우터를 통해 경로를 선택하고, 해당 경로에 따라 패킷을 전달
- 라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행
- ex) 라우터, IP

### 4) 전송 계층

- 종단 시스템 간에 데이터를 신뢰성있게 전송하는 역할
- 에러 검출 및 복구, 흐름 제어, 혼잡 제어 등의 기능을 수행
- 주로 TCP, UDP 프로토콜 사용
- 네트워크 계층 vs 전송 계층 : 네트워크 계층은 호스트 간의 논리적 통신을 돕지만, 전송 계층은 응용 프로세스 간의 논리적인 통신을 돕는다

### 5) 세션 계층

- 통신 세션을 관리하고, 세션 연결을 설정하고 유지하는 계층
- 응용 프로세스 간에 연결을 설정, 유지, 종료시켜주는 역할
- 가장 중요한 기능 중 하나는 세션 복원(Session Recovery) : 장애 발생 시 세션 정보를 저장하고 복원하여 세션 연결 유지

- ex) API, Socket

### 6) 표현 계층

- 데이터의 표현 방식을 정의
- 암호화, 압축, 포맷 등의 변환 기능을 수행
- 데이터 표현 차이를 해결하기 위해 서로 다른 형식으로 변환하거나 공통 형식을 제공하는 계층
- ex) jpeg, mpeg 등

### 7) 응용 계층

- 실질적인 프로그램
- 최종 사용자와 직접적으로 상호작용하여 응용 프로그램 간에 데이터 전송을 가능하게 함
- ex) http, ftp, dns 등

<br>
<br>

## TCP 3-way handshake & 4-way handshake

### TCP란?

OSI 모델에서 4계층에서 사용하는 프로토콜로, 장치들 사이에 논리적인 접속을 성립하기 위한 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.

- 연결형 서비스로, 가상 회선 패킷 교환 방식을 제공
- 3-way handshake 과정을 통해 연결을 설정하고, 4-way handshake을 통해 연결을 해제
- 흐름 제어 및 혼잡 제어를 제공
  - 흐름 제어 : 데이터를 송신하는 곳과 수신하는 곳의 **데이터 처리 속도를 조절**하여 수신자의 버퍼 오버플로우를 방지하는 것
  - 혼잡 제어 : **네트워크 내의 패킷 수가 증가하지 않도록 방지**하는 것

- 높은 신뢰성을 보장
- UDP 보다 속도가 느리다.
- 연속성 보다 신뢰성 있는 전송이 중요할 때 사용

<br>

### TCP 3-way handshake

- TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정
- TCP를 이용한 통신을 할 때 가장 먼저 수행되는 과정
- 상대방 컴퓨터와 사전에 세션을 수립하는 과정

![image-20230507003410060](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230507003410060.png)

1. 클라이언트가 서버에게 요청 패킷을 보낸다 : `SYN`
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보낸다 : `SYN` + `ACK`
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다 :`ACK`

### TCP 4-way handshake

- TCP의 연결을 해제하는 과정

![image-20230507003615775](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230507003615775.png)

1. 클라이언트가 서버에게 연결을 종료하겠다는 패킷을 보낸다 : `FIN`
2. 서버는 일단 알겠다는 확인 메세지를 보낸다 : `ACK`
3. 서버는 자신의 통신이 끝나면, 연결 요청에 합의한다는 의미로 패킷 전송 : `FIN`
4. 클라이언트는 알겠다는 확인 패킷을 전송 : `ACK`

<br>

<br>

## UDP

- User Datagram Protocol의 약자로, 데이터를 **데이터그램(Datagram)** 단위로 처리하는 프로토콜
- TCP와는 다르게 데이터를 패킷으로 나누고 반대편에서 재조립하는 과정을 거치지 않는다
- 수신지에서 제대로 받든 받지 않든 상관하지 않고 데이터를 보내기만 한다
- **비연결형, 신뢰성 없는 전송 프로토콜**
- TCP 처럼 연결 과정을 거치지 않기 때문에, UDP는 속도가 빠르다
- 이러한 속도의 장점으로 실시간 방송 등에 사용된다.

|                         | TCP              | UDP                |
| ----------------------- | ---------------- | ------------------ |
| **데이터 전송단위**     | 세그먼트         | 데이터그램         |
| **서비스의 형태**       | 연결형           | 비연결형           |
| **수신 순서**           | 송신 순서와 동일 | 수신 순서와 불일치 |
| **오류 제어, 흐름제어** | 있음             | 없음               |

### TCP와 UDP에서 오류는 어떻게 해결하는가?

TCP

- 데이터의 분실, 중복, 순서가 뒤바뀜을 자동으로 보정해줘서 송수신 데이터의 정확한 전달을 할 수 있게 해줌

UDP

- IP가 제공하는 정도의 수준만을 제공하는 간단한 IP 상위 계층의 프로토콜
- TCP와는 다르게 에러가 날 수도 있고, 재전송이나 순서가 뒤바뀔 수도 있음
- 이러한 경우 애플리케이션에서 처리해야한다는 번거로움 존재

### DNS에서 UDP의 사용

DNS는 데이터를 교환하는 경우로, 이런 경우 TCP를 사용하게 되면, 데이터를 송신할 때 세션 확립을 위한 처리를 해야하며, 송신한 데이터가 수신되었는지 점검하는 과정도 필요하기 때문에 UDP에 비해 프로토콜 오버헤드가 크다.

#### **사용 이유**

1. **빠른 속도**
   - TCP가 3-way handshake를 사용하는 반면, UDP는 연결 설정에 드는 비용이 없다
   - DNS는 신뢰성 보다는 속도가 중요한 서비스이기 때문에, UDP가 더 적합
   - UDP는 512 byte를 넘어가지 않는 패킷만 전송이 가능하고 오버헤드가 없어서 속도가 빠른데, DNS가 전송하는 데이터 패킷 사이즈가 매우 작으므로 UDP가 유리
   - 이때, 단순히 패킷의 사이즈가 작다고 DNS가 UDP를 채택한 것은 아니고, 전달하는 패킷의 크기가 작기 때문에 신뢰성이 보장되지 않아도 되기 때문이다 (못 받으면 다시 전달하면 된다)
2. **연결 상태를 유지할 필요가 없다**
   - UDP는 어떤 정보도 기록하지 않고, 유지할 필요도 없다
   - 따라서 DNS 서버는 더 많은 클라이언트를 수용할 수 있고, 연결 상태를 유지하지 않으며 정보 기록을 최소화할 수 있는 UDP를 채택하였다

<br>

<br>

## HTTP와 HTTPS

### HTTP

- Hypertext Transfer Protocol의 약자로, 클라이언트/서버 모델에 따라 데이터를 주고 받기 위한 모델
- 7계층의 프로토콜로, **TCP/IP 위에서 동작하며 80번 포트를 사용**한다
- 상태를 가지지 않고 있는 **stateless 프로토콜**이며, Method, Path, Version, Headers, Body 등으로 구성된다

![image-20230507014459556](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230507014459556.png)

- **평문 데이터(텍스트)를 전송하는 프로토콜**
- 누군가 네트워크에서 신호를 가로채면 내용이 노출될 수 있다는 **보안 이슈가 존재**

-> 이러한 보안 이슈를 해결하기 위해 HTTPS 등장

### HTTPS

- HTTP에 데이터 암호화를 추가하여 보안성을 강화한 프로토콜
- HTTP Secure라고도 불리며, 443번 포트를 사용
- HTTP 레이어 바로 밑단에 SSL을 추가하여, 인터넷 상에서 정보를 암호화

### 대칭키 암호화와 비대칭키 암호화

- HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용(혼용)
- 비대칭키 암호화 방식 2가지
  - 공개키 암호화 : 공개키로 암호화하면 개인키로만 복호화할 수 있다 -> 개인키는 나만 가지므로, 나만 볼 수 있다
  - 개인키 암호화 : 개인키로 암호화하면 공개키로만 복호화할 수 있다 -> 내가 인증한 정보임을 알려 신뢰성을 보장

<br>

HTTPS 연결 과정(hand-shaking)에서는 먼저 서버와 클라이언트 간에 세션키를 교환한다. 여기서 세션키란, 주고 받는 데이터를 암호화하기 위해 사용되는 대칭키이며, 데이터 간의 교환에는 빠른 연산 속도가 필요하므로 세션키는 대칭키로 만들어진다.

정리하자면, 처**음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 <u>비대칭키 암호화 방식</u>이 사용되고, 이후 데이터를 교환하는 과정에서는 빠른 연산 속도를 위해 <u>대칭키 암호화 방식</u>을 사용**하는 것이다. 

> SSH 키 기반 인증 방식

### HTTPS 통신 흐름

1. 클라이언트(브라우저)가 서버로 최초 연결을 시도한다
2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨준다
3. 클라이언트(브라우저)는 인증서의 유효성을 검사하고 세션키를 발급한다
4. 클라이언트(브라우저)는 세션키를 보관하며, 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송한다
5. 서버는 암호화된 세션키를 서버의 개인키로 복호화하여 세션키를 얻는다
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행한다

<br>

<br>

## TLS/SSL Handshake

### HTTPS를 사용한 안전한 웹

- 인터넷은 안전한 통신을 위해 암호화를 진행 : HTTPS(Hypertext Transfer Protocol Secure)
- HTTPS는 SSL(Secure Socket Layer)/TLS(Transport Layer Security) 전송 기술을 사용한다
- TCP, UDP와 같은 일반적인 인터넷 통신에 안전한 계층(Layer)를 추가하는 방식

### TLS/SSL Handshake

- HTTPS에서 클라이언트와 서버간 통신 전 SSL 인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식

![image-20230507005103435](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230507005103435.png)

### SSL 인증서

- 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)와 서버 측 공개키가 들어있다
- 서버에서는 키 페어(공개키 + 개인키)를 생성하고, 클라이언트가 사용할 서버의 공개키는 인증서에 담기게 된다

<br>

<br>

## www.naver.com을 쳤을 때 일어나는 일

### URL을 IP 주소로 변환

DNS 영역을 사용하여 계층적으로 수행된다. 

요약 : 캐싱 확인 -> 없으면 -> Root DNS -> TLD Dns -> 도메인 DNS

![image-20230507045927887](https://raw.githubusercontent.com/na3150/typora-img/main/uPic/image-20230507045927887.png)

1. PC 브라우저에서 `www.naver.com`을 입력한다.
2. PC는 미리 설정되어있는 DNS(local DNS)에게 `www.naver.com`이라는 hostname에 대한 ip 주소를 물어본다.
3. ISP DNS에 `www.naver.com` 에 대한 주소가 캐싱되어있다면 해당 IP 주소를 반환하고, 그렇지 않으면 다음 단계로 넘어간다.
4. Local DNS는 `www.naver.com` 에 대한 주소를 찾아내기 위해 다른 DNS 서버들과 통신을 시작한다. 먼저 Root DNS 서버에게 `www.naver.com` 에 대한 IP 주소를 아는 지에 대해 질의한다.
5. Root DNS 서버는 `com` 도메인을 관리하는 TLD DNS 서버의 정보를 포함하여 응답한다.
6. Local DNS 서버는 `com` Domain을 관리하는 DNS 서버에게 `www.naver.com` 에 대한 IP 주소를 아는지에 대해 질의한다.
7. com DNS 서버는 `naver.com`  도메인을 관리하는 DNS 서버의 정보를 포함하여 응답한다.
8. Local DNS 서버는 `naver.com` 도메인을 관리하는 DNS 서버에게 `www.naver.com` 에 대한 IP 주소를 아는 지에 대해 질의 한다.
9. IP 주소를 수신한 Local DNS 는 `www.naver.com` 에 대한 IP 주소를 캐싱하고, 단말(PC)에 전달해준다.



### 2. 대상 서버와 TCP 연결

- 브라우저가 IP 주소를 받게되면, tcp 프로토콜을 사용한다고 가정했을 때 (udp는 이 단계 생략)
- http 요청의 경우 일반적으로 tcp를 사용
- 3-way handshake를 통해 서버와 연결
- 추가적으로 https의 경우 3-way handshake에 TLS/SSL handshake도 추가된다.



### 3. HTTP 프로토콜 요청 및 응답

- 이제 연결이 확정되었으니 
- 브라우저는 해당 페이지 www.naver.com를 달라고 서버에게 HTTP Request(Get 요청)을 전송
- 서버에서 해당 요청을 받고, 이 요청을 수락할 수 있는지 검사하고 서버는 이 요청에 대한 응답(HTTP response)을 생성하여 브라우저에게 전달한다.



### 4. 브라우저에서 응답을 해석

- 서버에서 응답한 내용은 HTML, CSS, Javascript 등으로 이루어져있다
- 이를 브라우저에서 해석하여 그려준다
- 각종 텍스트를 정해진 형식을 해석하여 우리가 원하는 www.naver.com 페이지가 그려진다. 











